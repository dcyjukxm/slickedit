/**
 * Adds or replaces an icon in a specific folder.  If the program folder 
 * specified in szProgramFolder does not exist, AddFolderIcon will create it.  
 * @param szProgramFolder
 *   The name of the folder to which you are adding the icon.  If you are 
 *   calling AddFolderIcon to add a shortcut icon to the Windows 95 Start 
 *   Programs menu, use a null string ("") in this parameter.  
 *   <LI>szProgramFolder
 *   <LI>""
 *   <LI>FOLDER_DESKTOP
 *   <LI>FOLDER_STARTMENU
 *   <LI>FOLDER_STARTUP
 *   <LI>FOLDER_PROGRAMS
 * @param szItemName
 *   Enter the name of the icon that you are adding to the folder or to the 
 *   Windows 95 Start Programs menu.  
 * @param szCommandLine
 *   Enter either the fully qualified path and filename of the executable 
 *   associated with the icon you are adding, including any command line 
 *   parameters.  
 * @param szWorkingDir
 *   Enter the folder where your application's program files are located.  
 * @param szIconPath
 *   Enter the filename for the icon you want to display.  
 * @param nIcon
 *   Enter the icon ordinal in the Windows executable specified in szIconPath.  
 * @param szShortCutKey
 *   Enter the shortcut key (in the form of a string) that allows you to 
 *   quickly start your application.  
 * @param nFlag
 *   Specify icon appearance.  You can combine constants with the bitwise OR 
 *   operator ( | ).  
 *   <LI>REPLACE
 *   <LI>RUN_MAXIMIZED
 *   <LI>RUN_MINIMIZED
 *   <LI>RUN_SEPARATEMEMORY
 *   <LI>NULL
 */
function LONG AddFolderIcon(rul_program_folder szProgramFolder, STRING szItemName, STRING szCommandLine, STRING szWorkingDir, STRING szIconPath, NUMBER nIcon, STRING szShortCutKey, rul_folder_flag nFlag);
private enum rul_folder_flag {
   REPLACE
   RUN_MAXIMIZED
   RUN_MINIMIZED
   RUN_SEPARATEMEMORY
   NULL
}
private enum rul_program_folder {
   '""',
   FOLDER_DESKTOP
   FOLDER_STARTMENU
   FOLDER_STARTUP
   FOLDER_PROGRAMS
}
/**
 * Unconditionally adds a profile string to an INI file.  Use AddProfString 
 * only to add non-unique keys.  AddProfString adds the KEY=VALUE line to the 
 * beginning of the specified INI file section.  \n\n** Not available in 
 * Visual C++ Edition ** 
 * @param szFileName
 *   The fully qualified path and name of the INI file to which you are adding 
 *   the profile string.  If you do not specify a path, Windows assumes the 
 *   file is located in the Windows folder.  
 * @param szSectionName
 *   The name of the section of the INI file where you want to add the profile 
 *   string.  Do not include section name delimiting brackets ( [] ).  If the 
 *   section does not exist, InstallShield creates it for you.  
 * @param szKeyName
 *   The name of the key you are placing in the section.  The line szKeyName = 
 *   szValue is placed at the beginning of the section, even if a szKeyName 
 *   entry already exists.  
 * @param szValue
 *   The value you are placing after szKeyName.  
 */
function LONG AddProfString(STRING szFileName, STRING szSectionName, STRING szKeyName, STRING szValue);
/**
 * Controls the Program Manager.  If the target system does not have the 
 * Program Manager, this function may not work.  AppCommand has no effect 
 * under the Windows 95 shell.  \n\n** Not available in Visual C++ Edition ** 
 * @param nObject
 *   The name of the Program Manager.  Use the constant PROGMAN for this 
 *   parameter.  
 * @param nCommand
 *   Specify the command (message) you want to send to the Program Manager.  
 *   <LI>CMD_CLOSE
 *   <LI>CMD_MAXIMIZE
 *   <LI>CMD_MINIMIZE
 *   <LI>CMD_PUSHDOWN
 *   <LI>CMD_RESTORE
 */
function LONG AppCommand(NUMBER nObject, rul_command nCommand);
private enum rul_command {
   CMD_CLOSE
   CMD_MAXIMIZE
   CMD_MINIMIZE
   CMD_PUSHDOWN
   CMD_RESTORE
}
/**
 * Creates the dialog box which queries the user for where the application is 
 * to be installed.  
 * @param szTitle
 *   Enter the text you want to set as the title of the dialog box.  
 * @param szMsg
 *   Enter the message you want to display.  You can enter multiple lines of 
 *   static text in this parameter.  
 * @param svDir
 *   Enter the default path you want to display.  This parameter will also 
 *   contain the selected folder entered after the function executes.  
 * @param nReserved
 *   Enter 0 (zero) in this parameter.  No other value is allowed.  
 */
function LONG AskDestPath(STRING szTitle, STRING szMsg, BYREF STRING svDir, NUMBER nReserved);
/**
 * Displays a dialog box offering selection from one or more options using 
 * check boxes or radio buttons.  You can display up to nine options 
 * (szTextn, nvCheckn pairs).  
 * @param nValue
 *   Specify the controls as radio buttons (EXCLUSIVE) or
 *   check boxes (NONEXCLUSIVE).  
 * @param szMsg
 *   Enter a message to display in the dialog box.  
 * @param szText1
 *   Enter text (up to 47 characters) to display next to the first check box or 
 *   radio button.  
 * @param nvCheck1
 *   When AskOptions returns, nvCheck1 is set to TRUE if the first check box or 
 *   radio button was selected, FALSE if deselected.  
 * @param szText2
 *   Enter text (up to 47 characters) to display next to the second check box 
 *   or radio button.  
 * @param nvCheck2
 *   When AskOptions returns, nvCheck2 is set to TRUE if the second check box 
 *   or radio button was selected, FALSE if deselected.  
 */
function LONG AskOptions(rul_exclusive nValue, STRING szMsg, STRING szText1, BYREF NUMBER nvCheck1, STRING szText2, BYREF NUMBER nvCheck2[, STRING szTextn, BYREF NUMBER nvCheckn] [, ..., ...]);
private enum rul_exclusive {
   EXCLUSIVE
   NONEXCLUSIVE
}
/**
 * Displays a dialog box that asks the user to enter a destination location 
 * path.  
 * @param szMsg
 *   The message you want to display.  
 * @param szDefPath
 *   The default path you want to display in the edit field.  The user can 
 *   modify this string.  
 * @param svResultPath
 *   AskPath returns the resulting path string in svResultPath, regardless of 
 *   whether the user accepts the default path or modifies it and clicks Next.  
 *   AskPath adds a backslash to the end of the path before placing it into 
 *   svResultPath.  
 */
function LONG AskPath(STRING szMsg, STRING szDefPath, BYREF STRING svResultPath);
/**
 * Builds a dialog box displaying a question or a statement.  
 * @param szQuestion
 *   Enter the question or statement to display.  
 * @param szDefault
 *   Enter the default text that you want to appear in the edit field.  
 * @param svResult
 *   When the user clicks the Next button, svResult returns the text string the 
 *   user has entered.  
 */
function LONG AskText(STRING szQuestion, STRING szDefault, BYREF STRING svResult);
/**
 * Asks a question that the user can answer by clicking on a Yes or No push 
 * button.  
 * @param szQuestion
 *   Enter the question you want to display in the message box.  
 * @param nDefault
 *   Set the default focus to either the Yes or the No pushbutton.  
 */
function LONG AskYesNo(STRING szQuestion, rul_yes_no nDefault);
private enum rul_yes_no {
   YES
   NO
}
/**
 * Adds a DOS command to the Autoexec.bat file.  You can specify the position 
 * of the statement relative to a reference key, add the statement as the 
 * first or last line, or replace an existing line in the file.  
 * @param szKey
 *   The key word you are adding to the Autoexec.bat file.  PATH, TEMP, and 
 *   MYENV are examples of valid keys you can use for this parameter.  
 * @param szValue
 *   The value of the key you are adding to the Autoexec.bat file.  
 * @param szRefKey
 *   The reference key relative to which you are adding szKey in the 
 *   Autoexec.bat file.  
 * @param nOptions
 *   This specifies the placement of the new command relative to szRefKey.  
 *   <LI>BEFORE
 *   <LI>AFTER
 *   <LI>REPLACE
 */
function LONG BatchAdd(STRING szKey, STRING szValue, STRING szRefKey, rul_add_where nOptions);
private enum rul_add_where {
   BEFORE
   AFTER
   REPLACE
}
/**
 * Deletes a line or multiple lines identified in the szKey parameter.  You 
 * must call the BatchFileLoad function prior to calling the BatchDeleteEx 
 * function.  
 * @param szKey
 *   The reference keyword that identifies the line or lines you are deleting.  
 * @param nOptions
 *   Indicate whether szKey contains a command statement or an environment 
 *   variable.  
 *   <LI>0
 *   <LI>COMMAND
 */
function LONG BatchDeleteEx(STRING szKey, rul_command_or_0 nOptions);
private enum rul_command_or_0 {
   COMMAND
   0
}
/**
 * Loads a copy of a specified file into memory so that all advanced batch 
 * file functions can operate on the file.  Before using any of the advanced 
 * batch file functions you must call BatchFileLoad to load a copy of the 
 * batch file into memory.  
 * @param szBatchFile
 *   The fully qualified path and filename of the batch file you are loading 
 *   into memory.  
 */
function LONG BatchFileLoad(STRING szBatchFile);
/**
 * Saves the batch file loaded in memory back to the disk.  You must call 
 * this function to save the batch file you loaded into memory and modified 
 * using the advanced batch file functions.  Otherwise, all modifications 
 * will be lost.  The original file is renamed to the specified backup 
 * filename.  
 * @param szBackupFile
 *   The new filename you are giving to the original file you loaded into 
 *   memory.  This parameter can contain only the filename.  Do not include 
 *   path information here.  
 */
function LONG BatchFileSave(STRING szBackupFile);
/**
 * Searches a batch file for one or more occurrences of the reference key 
 * specified in szRefKey.  You must call the BatchFileLoad function prior to 
 * calling the BatchFind function.  
 * @param szRefKey
 *   The reference key you are searching for.  The reference key can be either 
 *   an environment variable or a command.  
 * @param svResult
 *   BatchFind returns the value of the reference key that was found in the 
 *   batch file in svResult.  
 * @param nOptions
 *   Indicate whether to start searching for szRefKey from the beginning of the 
 *   file (RESTART), or to continue from the current position in the file 
 *   (CONTINUE).  COMMAND indicates szRefKey is a command.  
 *   <LI>COMMAND
 *   <LI>CONTINUE
 *   <LI>RESTART
 */
function LONG BatchFind(STRING szRefKey, BYREF STRING svResult, rul_command_continue_restart nOptions);
private enum rul_command_continue_restart {
   COMMAND
   CONTINUE
   RESTART
}
/**
 * Retrieves the fully qualified path and filename of the default batch file.  
 * @param svFileName
 *   BatchGetFileName returns the fully qualified name of the default batch 
 *   file in svFileName.  
 */
function LONG BatchGetFileName(BYREF STRING svFileName);
/**
 * Moves one line relative to another line in a batch file.  
 * @param szMove
 *   The string that identifies the line you are moving.  
 * @param szRefKey
 *   The key that identifies the reference line used to position the line you 
 *   are moving.  
 * @param nOptions
 *   Identify where to move the line.  BEFORE means before the szRefKey line or 
 *   to the start of the file if szRefKey is "".  After means after the 
 *   szRefKey line or to the end of the file if szRefKey is "".  COMMAND means 
 *   szRefKey is a command.  
 *   <LI>BEFORE
 *   <LI>AFTER
 *   <LI>COMMAND
 * @param nMoveOption
 *   Specify whether szMove is an environment variable (0) or a command (COMMAND).  
 *   <LI>0
 *   <LI>COMMAND
 */
function LONG BatchMoveEx(STRING szMove, STRING szRefKey, rul_add_command nOptions, rul_command_or_0 nMoveOption);
private enum rul_add_command {
   BEFORE
   AFTER
   COMMAND
}
/**
 * Specifies the path and filename of the file you want to use as the default 
 * batch file.  The default batch file is initially set to be the bootup 
 * batch file.  This function does not check to see if the file exists.  
 * @param szBatchFile
 *   The fully qualified path and filename of the file you want to use as the 
 *   default batch file.  
 */
function LONG BatchSetFileName(STRING szBatchFile);
/**
 * Calls a function within a specified DLL.  
 * @param szDLL
 *   Enter the path and filename of the DLL that contains the function you wish 
 *   to call.  
 * @param szFunction
 *   Enter the name of the function you are calling from the DLL specified in 
 *   szDLL.  
 * @param lvValue
 *   You can use this parameter to pass data to your DLL function.  This 
 *   parameter is of type LONG (four bytes).  It is passed by reference to the 
 *   DLL function.  
 * @param svValue
 *   Enter the string you want to pass to the DLL function.  
 */
function LONG CallDLLFx(STRING szDLL, STRING szFunction, BYREF LONG lvValue, BYREF STRING svValue);
/**
 * Sets the current folder.  
 * @param szPath
 *   The fully qualified path of the folder you are setting as the new current 
 *   folder.  If the path in szPath contains a trailing backslash, you must 
 *   strip it off using StrRemoveLastSlash.  
 */
function LONG ChangeDirectory(STRING szPath);
/**
 * Closes a file after you have read from or written to the file.  You cannot 
 * read from or write to the file after you close it.  
 * @param nvFileHandle
 *   Enter the file handle that specifies the file you want to close.  
 */
function LONG CloseFile(BYREF NUMBER nvFileHandle);
/**
 * Retrieves the window handle of the dialog box identified by szDialogName.  
 * The dialog box already must have been defined with the DefineDialog 
 * function and created with the WaitOnDialog function.  \n\n** Not available 
 * in Visual C++ Edition ** 
 * @param szDialogName
 *   The name of a valid dialog box.  
 */
function LONG CmdGetHwndDlg(STRING szDialogName);
/**
 * Ensures that when Windows is restarted, .dll and .exe files that were 
 * locked during file transfer will be updated based on date.  
 * @param lReserved
 *   Enter 0 (zero) in this parameter.  No other value is allowed.  
 */
function LONG CommitSharedFiles(LONG lReserved);
/**
 * Adds a component to a set of script-created components.  If the specified 
 * media does not exist, it will be created.  ComponentAddItem does not work 
 * with file media libraries.  
 * @param szMedia
 *   The media name of a script-created component set to be added to and 
 *   created, if necessary.  
 * @param szComponent
 *   The name of the component to be added.  
 * @param nDataSize
 *   The size in bytes of the data the component represents.  If the component 
 *   is a series of files, enter the total uncompressed size of all the files.  
 * @param bSelected
 *   Specify the default selection setting of the component: TRUE for selected, 
 *   FALSE for unselected.  
 *   <LI>TRUE
 *   <LI>FALSE
 */
function LONG ComponentAddItem(STRING szMedia, STRING szComponent, NUMBER nDataSize, BOOL bSelected);
/**
 * Determines if there is enough available space on the target drive for all 
 * selected components.  If the drive does not have enough space, the target 
 * path and size required will be returned.  
 * @param szMedia
 *   Name of the media containing the components.  
 * @param svTarget
 *   If the target drive does not have enough space, the target path is 
 *   returned in svTarget.  
 * @param nvSize
 *   Required size returned if the target drive does not have enough space.  
 */
function LONG ComponentCompareSizeRequired(STRING szMedia, BYREF STRING svTarget, BYREF NUMBER nvSize);
/**
 * Displays a list of components the user can install.  The user can also 
 * select a destination folder.  
 * @param szTitle
 *   The text you want to appear as the dialog box title.  
 * @param szMsg
 *   The message you want to display in the dialog box.  For example, the 
 *   message might read "Please select one or more of the following components 
 *   to install on your system." 
 * @param svDir
 *   The destination location.  svDir will contain the selected location when 
 *   the function returns.  You must assign it to TARGETDIR or to a 
 *   script-defined variable to affect file transfer.  
 * @param szComponent
 *   The name of the component(s) you want to display.  If szComponent is a 
 *   null string (""), all top-level components are displayed.  If szComponent 
 *   is a component name, its subcomponents are displayed.  
 */
function LONG ComponentDialog(STRING szTitle, STRING szMsg, BYREF STRING svDir, STRING szComponent);
/**
 * Retrieves extra error information after a component function returns a 
 * value less than zero.  Do not use ComponentError after 
 * ComponentSetupTypeEnum or ComponentSetupTypeSet.  
 * @param svMedia
 *   When relevant to the error indicated in nvError, the name of the media 
 *   involved is returned in svMedia.  
 * @param svComponent
 *   When relevant to the error indicated in nvError, the name of the component 
 *   involved is returned in svComponent.  
 * @param svFileGroup
 *   When relevant to the error indicated in nvError, the name of the file 
 *   group involved is returned in svFileGroup.  
 * @param svFile
 *   When relevant to the error indicated in nvError, the name of the file 
 *   involved is returned in svFile.  
 * @param nvError
 *   When ComponentError is called after a component-related function returns a 
 *   value less than zero, the error code is stored in nvError.  
 */
function LONG ComponentError(BYREF STRING svMedia, BYREF STRING svComponent, BYREF STRING svFileGroup, BYREF STRING svFile, BYREF NUMBER nvError);
/**
 * Enumerates files in a component.  Does not work with script-created 
 * components.  
 * @param szMedia
 *   The name of the media containing the component.  
 * @param szComponent
 *   The name of the component to be file-enumerated.  
 * @param szQuery
 *   Enumeration specification.  
 * @param listFiles
 *   List storing the enumeration results.  
 * @param nOption
 *   Specify whether or not to include subdirectories in the enumeration.  
 *   <LI>INCLUDE_SUBDIR
 *   <LI>NO_SUBDIR
 */
function LONG ComponentFileEnum(STRING szMedia, STRING szComponent, STRING szQuery, LIST listFiles, rul_subdir_flags nOption);
private enum rul_subdir_flags {
   INCLUDE_SUBDIR
   NO_SUBDIR
}
/**
 * Retrieves all available information on the specified file in the media.  
 * Does not work with script-created components.  
 * @param szMedia
 *   The name of the media containing the file.  
 * @param szComponent
 *   The name of the component containing the file.  
 * @param szFile
 *   Query specification.  
 * @param nInfo
 *   Type of information to be retrieved.  
 *   <LI>COMPONENT_INFO_LANGUAGE
 *   <LI>COMPONENT_INFO_OS
 *   <LI>COMPONENT_INFO_ORIGSIZE
 *   <LI>COMPONENT_INFO_COMPSIZE
 *   <LI>COMPONENT_INFO_DATE
 *   <LI>COMPONENT_INFO_DATE_EX
 *   <LI>COMPONENT_INFO_TIME
 *   <LI>COMPONENT_INFO_ATTRIBUTE
 *   <LI>COMPONENT_INFO_VERSIONMS
 *   <LI>COMPONENT_INFO_VERSIONLS
 *   <LI>COMPONENT_INFO_VERSIONSTR
 * @param nvResult
 *   Stores a numeric query result.  (Stores a number list ID if nInfo is 
 *   COMPONENT_INFO_LANGUAGE or COMPONENT_INFO_OS.) 
 * @param svResult
 *   Stores a string query result.  
 */
function LONG ComponentFileInfo(STRING szMedia, STRING szComponent, STRING szFile, rul_component_info_flags nInfo, BYREF NUMBER nvResult, BYREF STRING svResult);
private enum rul_component_info_flags {
   COMPONENT_INFO_LANGUAGE
   COMPONENT_INFO_OS
   COMPONENT_INFO_ORIGSIZE
   COMPONENT_INFO_COMPSIZE
   COMPONENT_INFO_DATE
   COMPONENT_INFO_DATE_EX
   COMPONENT_INFO_TIME
   COMPONENT_INFO_ATTRIBUTE
   COMPONENT_INFO_VERSIONMS
   COMPONENT_INFO_VERSIONLS
   COMPONENT_INFO_VERSIONSTR
}
/**
 * Filters (excludes) files from file transfer based on language.  By 
 * default, all languages included in the media build are unfiltered 
 * (included).  You must call ComponentFilterLanguage for each language you 
 * wish to filter or unfilter.  \n\n** Not available in Visual C++ Edition ** 
 * @param szMedia
 *   The name of the media being filtered.  
 * @param nLangID
 *   The language ID for the language to be filtered.  You cannot combine 
 *   language IDs.  
 *   <LI>ISLANG_ALL
 *   <LI>ISLANG_ARABIC
 *   <LI>ISLANG_ARABIC_SAUDIARABIA
 *   <LI>ISLANG_ARABIC_IRAQ
 *   <LI>ISLANG_ARABIC_EGYPT
 *   <LI>ISLANG_ARABIC_LIBYA
 *   <LI>ISLANG_ARABIC_ALGERIA
 *   <LI>ISLANG_ARABIC_MOROCCO
 *   <LI>ISLANG_ARABIC_TUNISIA
 *   <LI>ISLANG_ARABIC_OMAN
 *   <LI>ISLANG_ARABIC_YEMEN
 *   <LI>ISLANG_ARABIC_SYRIA
 *   <LI>ISLANG_ARABIC_JORDAN
 *   <LI>ISLANG_ARABIC_LEBANON
 *   <LI>ISLANG_ARABIC_KUWAIT
 *   <LI>ISLANG_ARABIC_UAE
 *   <LI>ISLANG_ARABIC_BAHRAIN
 *   <LI>ISLANG_ARABIC_QATAR
 *   <LI>ISLANG_AFRIKAANS
 *   <LI>ISLANG_AFRIKAANS_STANDARD
 *   <LI>ISLANG_ALBANIAN
 *   <LI>ISLANG_ALBANIAN_STANDARD
 *   <LI>ISLANG_BASQUE
 *   <LI>ISLANG_BASQUE_STANDARD
 *   <LI>ISLANG_BULGARIAN
 *   <LI>ISLANG_BULGARIAN_STANDARD
 *   <LI>ISLANG_BELARUSIAN
 *   <LI>ISLANG_BELARUSIAN_STANDARD
 *   <LI>ISLANG_CATALAN
 *   <LI>ISLANG_CATALAN_STANDARD
 *   <LI>ISLANG_CHINESE
 *   <LI>ISLANG_CHINESE_TAIWAN
 *   <LI>ISLANG_CHINESE_PRC
 *   <LI>ISLANG_CHINESE_HONGKONG
 *   <LI>ISLANG_CHINESE_SINGAPORE
 *   <LI>ISLANG_CROATIAN
 *   <LI>ISLANG_CROATIAN_STANDARD
 *   <LI>ISLANG_CZECH
 *   <LI>ISLANG_CZECH_STANDARD
 *   <LI>ISLANG_DANISH
 *   <LI>ISLANG_DANISH_STANDARD
 *   <LI>ISLANG_DUTCH
 *   <LI>ISLANG_DUTCH_STANDARD
 *   <LI>ISLANG_DUTCH_BELGIAN
 *   <LI>ISLANG_ENGLISH
 *   <LI>ISLANG_ENGLISH_UNITEDSTATES
 *   <LI>ISLANG_ENGLISH_UNITEDKINGDOM
 *   <LI>ISLANG_ENGLISH_AUSTRALIAN
 *   <LI>ISLANG_ENGLISH_CANADIAN
 *   <LI>ISLANG_ENGLISH_NEWZEALAND
 *   <LI>ISLANG_ENGLISH_IRELAND
 *   <LI>ISLANG_ENGLISH_SOUTHAFRICA
 *   <LI>ISLANG_ENGLISH_JAMAICA
 *   <LI>ISLANG_ENGLISH_CARIBBEAN
 *   <LI>ISLANG_ENGLISH_BELIZE
 *   <LI>ISLANG_ENGLISH_TRINIDAD
 *   <LI>ISLANG_ESTONIAN
 *   <LI>ISLANG_ESTONIAN_STANDARD
 *   <LI>ISLANG_FAEROESE
 *   <LI>ISLANG_FAEROESE_STANDARD
 *   <LI>ISLANG_FARSI
 *   <LI>ISLANG_FARSI_STANDARD
 *   <LI>ISLANG_FINNISH
 *   <LI>ISLANG_FINNISH_STANDARD
 *   <LI>ISLANG_FRENCH
 *   <LI>ISLANG_FRENCH_STANDARD
 *   <LI>ISLANG_FRENCH_BELGIAN
 *   <LI>ISLANG_FRENCH_CANADIAN
 *   <LI>ISLANG_FRENCH_SWISS
 *   <LI>ISLANG_FRENCH_LUXEMBOURG
 *   <LI>ISLANG_GERMAN
 *   <LI>ISLANG_GERMAN_STANDARD
 *   <LI>ISLANG_GERMAN_SWISS
 *   <LI>ISLANG_GERMAN_AUSTRIAN
 *   <LI>ISLANG_GERMAN_LUXEMBOURG
 *   <LI>ISLANG_GERMAN_LIECHTENSTEIN
 *   <LI>ISLANG_GREEK
 *   <LI>ISLANG_GREEK_STANDARD
 *   <LI>ISLANG_HEBREW
 *   <LI>ISLANG_HEBREW_STANDARD
 *   <LI>ISLANG_HUNGARIAN
 *   <LI>ISLANG_HUNGARIAN_STANDARD
 *   <LI>ISLANG_ICELANDIC
 *   <LI>ISLANG_ICELANDIC_STANDARD
 *   <LI>ISLANG_INDONESIAN
 *   <LI>ISLANG_INDONESIAN_STANDARD
 *   <LI>ISLANG_ITALIAN
 *   <LI>ISLANG_ITALIAN_STANDARD
 *   <LI>ISLANG_ITALIAN_SWISS
 *   <LI>ISLANG_JAPANESE
 *   <LI>ISLANG_JAPANESE_STANDARD
 *   <LI>ISLANG_KOREAN
 *   <LI>ISLANG_KOREAN_STANDARD
 *   <LI>ISLANG_KOREAN_JOHAB
 *   <LI>ISLANG_LATVIAN
 *   <LI>ISLANG_LATVIAN_STANDARD
 *   <LI>ISLANG_LITHUANIAN
 *   <LI>ISLANG_LITHUANIAN_STANDARD
 *   <LI>ISLANG_NORWEGIAN
 *   <LI>ISLANG_NORWEGIAN_BOKMAL
 *   <LI>ISLANG_NORWEGIAN_NYNORSK
 *   <LI>ISLANG_POLISH
 *   <LI>ISLANG_POLISH_STANDARD
 *   <LI>ISLANG_PORTUGUESE
 *   <LI>ISLANG_PORTUGUESE_BRAZILIAN
 *   <LI>ISLANG_PORTUGUESE_STANDARD
 *   <LI>ISLANG_ROMANIAN
 *   <LI>ISLANG_ROMANIAN_STANDARD
 *   <LI>ISLANG_RUSSIAN
 *   <LI>ISLANG_RUSSIAN_STANDARD
 *   <LI>ISLANG_SLOVAK
 *   <LI>ISLANG_SLOVAK_STANDARD
 *   <LI>ISLANG_SLOVENIAN
 *   <LI>ISLANG_SLOVENIAN_STANDARD
 *   <LI>ISLANG_SERBIAN
 *   <LI>ISLANG_SERBIAN_LATIN
 *   <LI>ISLANG_SERBIAN_CYRILLIC
 *   <LI>ISLANG_SPANISH
 *   <LI>ISLANG_SPANISH_TRADITIONALSORT
 *   <LI>ISLANG_SPANISH_MEXICAN
 *   <LI>ISLANG_SPANISH_MODERNSORT
 *   <LI>ISLANG_SPANISH_GUATEMALA
 *   <LI>ISLANG_SPANISH_COSTARICA
 *   <LI>ISLANG_SPANISH_PANAMA
 *   <LI>ISLANG_SPANISH_DOMINICANREPUBLIC
 *   <LI>ISLANG_SPANISH_VENEZUELA
 *   <LI>ISLANG_SPANISH_COLOMBIA
 *   <LI>ISLANG_SPANISH_PERU
 *   <LI>ISLANG_SPANISH_ARGENTINA
 *   <LI>ISLANG_SPANISH_ECUADOR
 *   <LI>ISLANG_SPANISH_CHILE
 *   <LI>ISLANG_SPANISH_URUGUAY
 *   <LI>ISLANG_SPANISH_PARAGUAY
 *   <LI>ISLANG_SPANISH_BOLIVIA
 *   <LI>ISLANG_SPANISH_ELSALVADOR
 *   <LI>ISLANG_SPANISH_HONDURAS
 *   <LI>ISLANG_SPANISH_NICARAGUA
 *   <LI>ISLANG_SPANISH_PUERTORICO
 *   <LI>ISLANG_SWEDISH
 *   <LI>ISLANG_SWEDISH_STANDARD
 *   <LI>ISLANG_SWEDISH_FINLAND
 *   <LI>ISLANG_THAI
 *   <LI>ISLANG_THAI_STANDARD
 *   <LI>ISLANG_TURKISH
 *   <LI>ISLANG_TURKISH_STANDARD
 *   <LI>ISLANG_UKRAINIAN
 *   <LI>ISLANG_UKRAINIAN_STANDARD
 *   <LI>ISLANG_VIETNAMESE
 *   <LI>ISLANG_VIETNAMESE_STANDARD
 * @param bFiltered
 *   Use one of the following constants to specify whether or not you want the 
 *   specified language(s) filtered (excluded).  
 *   <LI>TRUE
 *   <LI>FALSE
 */
function LONG ComponentFilterLanguage(STRING szMedia, rul_language_id nLangID, BOOL bFiltered);
private enum rul_language_id {
   ISLANG_ALL
   ISLANG_ARABIC
   ISLANG_ARABIC_SAUDIARABIA
   ISLANG_ARABIC_IRAQ
   ISLANG_ARABIC_EGYPT
   ISLANG_ARABIC_LIBYA
   ISLANG_ARABIC_ALGERIA
   ISLANG_ARABIC_MOROCCO
   ISLANG_ARABIC_TUNISIA
   ISLANG_ARABIC_OMAN
   ISLANG_ARABIC_YEMEN
   ISLANG_ARABIC_SYRIA
   ISLANG_ARABIC_JORDAN
   ISLANG_ARABIC_LEBANON
   ISLANG_ARABIC_KUWAIT
   ISLANG_ARABIC_UAE
   ISLANG_ARABIC_BAHRAIN
   ISLANG_ARABIC_QATAR
   ISLANG_AFRIKAANS
   ISLANG_AFRIKAANS_STANDARD
   ISLANG_ALBANIAN
   ISLANG_ALBANIAN_STANDARD
   ISLANG_BASQUE
   ISLANG_BASQUE_STANDARD
   ISLANG_BULGARIAN
   ISLANG_BULGARIAN_STANDARD
   ISLANG_BELARUSIAN
   ISLANG_BELARUSIAN_STANDARD
   ISLANG_CATALAN
   ISLANG_CATALAN_STANDARD
   ISLANG_CHINESE
   ISLANG_CHINESE_TAIWAN
   ISLANG_CHINESE_PRC
   ISLANG_CHINESE_HONGKONG
   ISLANG_CHINESE_SINGAPORE
   ISLANG_CROATIAN
   ISLANG_CROATIAN_STANDARD
   ISLANG_CZECH
   ISLANG_CZECH_STANDARD
   ISLANG_DANISH
   ISLANG_DANISH_STANDARD
   ISLANG_DUTCH
   ISLANG_DUTCH_STANDARD
   ISLANG_DUTCH_BELGIAN
   ISLANG_ENGLISH
   ISLANG_ENGLISH_UNITEDSTATES
   ISLANG_ENGLISH_UNITEDKINGDOM
   ISLANG_ENGLISH_AUSTRALIAN
   ISLANG_ENGLISH_CANADIAN
   ISLANG_ENGLISH_NEWZEALAND
   ISLANG_ENGLISH_IRELAND
   ISLANG_ENGLISH_SOUTHAFRICA
   ISLANG_ENGLISH_JAMAICA
   ISLANG_ENGLISH_CARIBBEAN
   ISLANG_ENGLISH_BELIZE
   ISLANG_ENGLISH_TRINIDAD
   ISLANG_ESTONIAN
   ISLANG_ESTONIAN_STANDARD
   ISLANG_FAEROESE
   ISLANG_FAEROESE_STANDARD
   ISLANG_FARSI
   ISLANG_FARSI_STANDARD
   ISLANG_FINNISH
   ISLANG_FINNISH_STANDARD
   ISLANG_FRENCH
   ISLANG_FRENCH_STANDARD
   ISLANG_FRENCH_BELGIAN
   ISLANG_FRENCH_CANADIAN
   ISLANG_FRENCH_SWISS
   ISLANG_FRENCH_LUXEMBOURG
   ISLANG_GERMAN
   ISLANG_GERMAN_STANDARD
   ISLANG_GERMAN_SWISS
   ISLANG_GERMAN_AUSTRIAN
   ISLANG_GERMAN_LUXEMBOURG
   ISLANG_GERMAN_LIECHTENSTEIN
   ISLANG_GREEK
   ISLANG_GREEK_STANDARD
   ISLANG_HEBREW
   ISLANG_HEBREW_STANDARD
   ISLANG_HUNGARIAN
   ISLANG_HUNGARIAN_STANDARD
   ISLANG_ICELANDIC
   ISLANG_ICELANDIC_STANDARD
   ISLANG_INDONESIAN
   ISLANG_INDONESIAN_STANDARD
   ISLANG_ITALIAN
   ISLANG_ITALIAN_STANDARD
   ISLANG_ITALIAN_SWISS
   ISLANG_JAPANESE
   ISLANG_JAPANESE_STANDARD
   ISLANG_KOREAN
   ISLANG_KOREAN_STANDARD
   ISLANG_KOREAN_JOHAB
   ISLANG_LATVIAN
   ISLANG_LATVIAN_STANDARD
   ISLANG_LITHUANIAN
   ISLANG_LITHUANIAN_STANDARD
   ISLANG_NORWEGIAN
   ISLANG_NORWEGIAN_BOKMAL
   ISLANG_NORWEGIAN_NYNORSK
   ISLANG_POLISH
   ISLANG_POLISH_STANDARD
   ISLANG_PORTUGUESE
   ISLANG_PORTUGUESE_BRAZILIAN
   ISLANG_PORTUGUESE_STANDARD
   ISLANG_ROMANIAN
   ISLANG_ROMANIAN_STANDARD
   ISLANG_RUSSIAN
   ISLANG_RUSSIAN_STANDARD
   ISLANG_SLOVAK
   ISLANG_SLOVAK_STANDARD
   ISLANG_SLOVENIAN
   ISLANG_SLOVENIAN_STANDARD
   ISLANG_SERBIAN
   ISLANG_SERBIAN_LATIN
   ISLANG_SERBIAN_CYRILLIC
   ISLANG_SPANISH
   ISLANG_SPANISH_TRADITIONALSORT
   ISLANG_SPANISH_MEXICAN
   ISLANG_SPANISH_MODERNSORT
   ISLANG_SPANISH_GUATEMALA
   ISLANG_SPANISH_COSTARICA
   ISLANG_SPANISH_PANAMA
   ISLANG_SPANISH_DOMINICANREPUBLIC
   ISLANG_SPANISH_VENEZUELA
   ISLANG_SPANISH_COLOMBIA
   ISLANG_SPANISH_PERU
   ISLANG_SPANISH_ARGENTINA
   ISLANG_SPANISH_ECUADOR
   ISLANG_SPANISH_CHILE
   ISLANG_SPANISH_URUGUAY
   ISLANG_SPANISH_PARAGUAY
   ISLANG_SPANISH_BOLIVIA
   ISLANG_SPANISH_ELSALVADOR
   ISLANG_SPANISH_HONDURAS
   ISLANG_SPANISH_NICARAGUA
   ISLANG_SPANISH_PUERTORICO
   ISLANG_SWEDISH
   ISLANG_SWEDISH_STANDARD
   ISLANG_SWEDISH_FINLAND
   ISLANG_THAI
   ISLANG_THAI_STANDARD
   ISLANG_TURKISH
   ISLANG_TURKISH_STANDARD
   ISLANG_UKRAINIAN
   ISLANG_UKRAINIAN_STANDARD
   ISLANG_VIETNAMESE
   ISLANG_VIETNAMESE_STANDARD
}
/**
 * Filters file groups that are flagged for specified operating systems.  By 
 * default, no operating systems are filtered.  \n\n** Not available in 
 * Visual C++ Edition ** 
 * @param szMedia
 *   The name of the media being filtered.  
 * @param nUpperOS
 *   The upper 32 bits of a 64-bit operating system identifier field.  nUpperOS 
 *   is currently not used.  Enter zero in this parameter.  No other value is 
 *   allowed.  
 * @param nLowerOS
 *   The lower 32 bits of a 64-bit operating system identifier field.  nLowerOS 
 *   specifies the operating system(s) you wish to filter.  You can combine 
 *   values using the bitwise OR operator ( | ).  
 *   <LI>ISOSL_ALL
 *   <LI>ISOSL_WIN31
 *   <LI>ISOSL_WIN95
 *   <LI>ISOSL_NT351
 *   <LI>ISOSL_NT351_ALPHA
 *   <LI>ISOSL_NT351_MIPS
 *   <LI>ISOSL_NT40
 *   <LI>ISOSL_NT40_ALPHA
 *   <LI>ISOSL_NT40_MIPS
 * @param bEnable
 *   Specifies whether or not you want to filter the operating systems 
 *   specified in nLowerOS.  Use one of the following constants.  
 *   <LI>TRUE
 *   <LI>FALSE
 */
function LONG ComponentFilterOS(STRING szMedia, NUMBER nUpperOS, rul_operating_system nLowerOS, BOOL bFiltered);
private enum rul_operating_system {
   ISOSL_ALL
   ISOSL_WIN31
   ISOSL_WIN95
   ISOSL_WIN98
   ISOSL_WINME
   ISOSL_NT351
   ISOSL_NT351_ALPHA
   ISOSL_NT351_MIPS
   ISOLS_NT351_PPC
   ISOSL_NT40
   ISOSL_NT40_ALPHA
   ISOSL_NT40_MIPS
   ISOSL_NT40_PPC
   ISOSL_NT2000
}
/**
 * Retrieves all available information on a component.  If the specified 
 * media is for script-created components, some information cannot be 
 * retrieved.  
 * @param szMedia
 *   The name of the media containing the component.  
 * @param szComponent
 *   The name of the component whose information you wish to retrieve.  
 * @param nInfo
 *   The type of information to retrieve.  
 *   <LI>COMPONENT_FIELD_DESCRIPTION
 *   <LI>COMPONENT_FIELD_DISPLAYNAME
 *   <LI>COMPONENT_FIELD_FILENEED
 *   <LI>COMPONENT_FIELD_FTPLOCATION
 *   <LI>COMPONENT_FIELD_HTTPLOCATION
 *   <LI>COMPONENT_FIELD_IMAGE
 *   <LI>COMPONENT_FIELD_OVERWRITE
 *   <LI>COMPONENT_FIELD_MISC
 *   <LI>COMPONENT_FIELD_PASSWORD
 *   <LI>COMPONENT_FIELD_SELECTED
 *   <LI>COMPONENT_FIELD_SIZE
 *   <LI>COMPONENT_FIELD_STATUS
 *   <LI>COMPONENT_FIELD_DESTINATION
 *   <LI>COMPONENT_FIELD_CDROM_FOLDER
 *   <LI>COMPONENT_FIELD_VISIBLE
 * @param nvResult
 *   Stores a numeric query result.  
 * @param svResult
 *   Stores a string query result.  
 */
function LONG ComponentGetData(STRING szMedia, STRING szComponent, rul_component_field_flags nInfo, BYREF NUMBER nvResult, BYREF STRING svResult);
private enum rul_component_field_flags {
   COMPONENT_FIELD_DESCRIPTION
   COMPONENT_FIELD_DISPLAYNAME
   COMPONENT_FIELD_FILENEED
   COMPONENT_FIELD_FTPLOCATION
   COMPONENT_FIELD_HTTPLOCATION
   COMPONENT_FIELD_IMAGE
   COMPONENT_FIELD_OVERWRITE
   COMPONENT_FIELD_MISC
   COMPONENT_FIELD_PASSWORD
   COMPONENT_FIELD_SELECTED
   COMPONENT_FIELD_SIZE
   COMPONENT_FIELD_STATUS
   COMPONENT_FIELD_DESTINATION
   COMPONENT_FIELD_CDROM_FOLDER
   COMPONENT_FIELD_VISIBLE
}
/**
 * Determines the size in bytes of a component.  Does not include sizes of 
 * subcomponents.  
 * @param szMedia
 *   The name of the media containing the component.  
 * @param szComponent
 *   The name of the component whose size you want to retrieve.  
 * @param nvSize
 *   The component size in bytes is returned in nvSize.  
 */
function LONG ComponentGetItemSize(STRING szMedia, STRING szComponent, BYREF NUMBER nvSize);
/**
 * Initializes the access of a specific file media library (.cab file and all 
 * its associated data files) and associates the specified media name with 
 * that file.  
 * @param szMedia
 *   The media name to be associated with the file specified in szMediaFile.  
 * @param szMediaFile
 *   The name of the file media library to be initialized.  Do not specify a 
 *   path; this file must reside in the setup's source folder (SRCDIR).  
 */
function LONG ComponentInitialize(STRING szMedia, STRING szMediaFile);
/**
 * Determines whether a specified component is selected.  
 * @param szMedia
 *   The name of the media containing the component whose selection setting you 
 *   want to test.  
 * @param szComponent
 *   The name of the component whose selection setting you want to test.  
 */
function LONG ComponentIsItemSelected(STRING szMedia, STRING szComponent);
/**
 * Enumerates all top-level components (if szComponent is "") or all 
 * subcomponents of the component specified in szComponent.  
 * @param szMedia
 *   The media containing the components and/or subcomponents you wish to 
 *   enumerate.  
 * @param szComponent
 *   The component whose subcomponents you wish to enumerate.  If szComponent 
 *   is a null string (""), all top-level components are enumerated.  
 * @param listComponents
 *   String list to receive the enumerated components or subcomponents.  
 */
function LONG ComponentListItems(STRING szMedia, STRING szComponent, LIST listComponents);
/**
 * Transfers/decompresses files from the file media library referenced by 
 * szMedia.  
 * @param szMedia
 *   The media name of the file media library.  Enter a null string ("") to 
 *   reset internal structures before subsequent calls to ComponentMoveData.  
 * @param nvDisk
 *   Contains the number of the last disk accessed by ComponentMoveData.  
 * @param nReserved
 *   Enter 0 (zero) in this parameter.  No other value is allowed.  
 */
function LONG ComponentMoveData(STRING szMedia, BYREF NUMBER nvDisk, NUMBER nReserved);
/**
 * Sets a component's selection status to either selected or unselected.  
 * @param szMedia
 *   The media name of the file media library or script-created component set 
 *   containing the component whose selection status you wish to set.  
 * @param szComponent
 *   The component whose selection status you wisth to set.  
 * @param bSelected
 *   Specify whether the component is selected (TRUE) or unselected (FALSE).  
 *   <LI>TRUE
 *   <LI>FALSE
 */
function LONG ComponentSelectItem(STRING szMedia, STRING szComponent, BOOL bSelected);
/**
 * Sets field data for the specified component.  If the media is for 
 * script-created components, some fields cannot be set.  
 * @param szMedia
 *   The name of the media containing the component.  
 * @param szComponent
 *   The name of the component whose field data you wish to set.  
 * @param nInfo
 *   The type of information to be set.  
 *   <LI>COMPONENT_FIELD_DESCRIPTION
 *   <LI>COMPONENT_FIELD_DISPLAYNAME
 *   <LI>COMPONENT_FIELD_FTPLOCATION
 *   <LI>COMPONENT_FIELD_HTTPLOCATION
 *   <LI>COMPONENT_FIELD_IMAGE
 *   <LI>COMPONENT_FIELD_OVERWRITE
 *   <LI>COMPONENT_FIELD_MISC
 *   <LI>COMPONENT_FIELD_SELECTED
 *   <LI>COMPONENT_FIELD_SIZE
 *   <LI>COMPONENT_FIELD_STATUS
 *   <LI>COMPONENT_FIELD_DESTINATION
 *   <LI>COMPONENT_FIELD_CDROM_FOLDER
 *   <LI>COMPONENT_FIELD_UNINSTALLABLE
 *   <LI>COMPONENT_FIELD_VISIBLE
 * @param nData
 *   The numeric data to be set.  
 *   <LI>TRUE
 *   <LI>FALSE
 *   <LI>COMPONENT_VALUE_ALWAYSOVERWRITE
 *   <LI>COMPONENT_VALUE_SAMEORNEWERDATE
 *   <LI>COMPONENT_VALUE_NEWERDATE
 *   <LI>COMPONENT_VALUE_OLDERDATE
 *   <LI>COMPONENT_VALUE_SAMEORNEWERVERSION
 *   <LI>COMPONENT_VALUE_NEWERVERSION
 *   <LI>COMPONENT_VALUE_OLDERVERSION
 *   <LI>COMPONENT_VALUE_NEVEROVERWRITE
 * @param szData
 *   The string value to be set.  
 */
function LONG ComponentSetData(STRING szMedia, STRING szComponent, rul_ComponentSetData_field nInfo, rul_ComponentSetData_value nData, STRING szData);
private enum rul_ComponentSetData_field {
   COMPONENT_FIELD_DESCRIPTION
   COMPONENT_FIELD_DISPLAYNAME
   COMPONENT_FIELD_FTPLOCATION
   COMPONENT_FIELD_HTTPLOCATION
   COMPONENT_FIELD_IMAGE
   COMPONENT_FIELD_OVERWRITE
   COMPONENT_FIELD_MISC
   COMPONENT_FIELD_SELECTED
   COMPONENT_FIELD_SIZE
   COMPONENT_FIELD_STATUS
   COMPONENT_FIELD_DESTINATION
   COMPONENT_FIELD_CDROM_FOLDER
   COMPONENT_FIELD_UNINSTALLABLE
   COMPONENT_FIELD_VISIBLE
}
private enum rul_ComponentSetData_value {
   TRUE
   FALSE
   COMPONENT_VALUE_ALWAYSOVERWRITE
   COMPONENT_VALUE_CRITICAL
   COMPONENT_VALUE_HIGHLYRECOMMENDED
   COMPONENT_VALUE_SAMEORNEWERDATE
   COMPONENT_VALUE_NEWERDATE
   COMPONENT_VALUE_OLDERDATE
   COMPONENT_VALUE_SAMEORNEWDATE
   COMPONENT_VALUE_SAMEORNEWERVERSION
   COMPONENT_VALUE_NEWERVERSION
   COMPONENT_VALUE_OLDERVERSION
   COMPONENT_VALUE_NEVEROVERWRITE
   COMPONENT_VALUE_STANDARD
}
/**
 * Associates a script variable with a user-defined variable in the 
 * Destination field of the Component Properties window.  Call 
 * ComponentSetTarget before calling ComponentMoveData.  Does not work with 
 * script-created components.  
 * @param szMedia
 *   The name of the media for which you wish to set the target location.  
 * @param szUserVar
 *   The user-defined variable entered in the Destination field of the 
 *   Component Properties window.  Enclose in quotes and include < > symbols: 
 *   "<szVar>".  
 * @param szLocation
 *   The variable whose value you wish to associate with the szUserVar 
 *   user-defined variable.  
 */
function LONG ComponentSetTarget(STRING szMedia, STRING szUserVar, STRING szLocation);
/**
 * Enumerates all setup types associated with the specified media.  These 
 * setup types are defined by you in the IDE and stored in the file media 
 * library.  Does not work with script-created components.  
 * @param szMedia
 *   Enter the name of the media.  
 * @param listSetupTypes
 *   String list to receive the enumerated setup types.  
 */
function LONG ComponentSetupTypeEnum(STRING szMedia, LIST listSetupTypes);
/**
 * Retrieves data associated with a specified setup type created in the 
 * InstallShield IDE.  You can then use this data for any purpose.  
 * @param szMedia
 *   Enter the name of the media containing the setup type.  
 * @param szSetupType
 *   Enter the name of the setup type.  
 * @param nInfo
 *   Indicate the kind of setup type information you want to get.  
 *   <LI>SETUPTYPE_INFO_DESCRIPTION
 *   <LI>SETUPTYPE_INFO_DISPLAYNAME
 * @param nvResult
 *   Receives a numeric result when nInfo gets numerica data.  
 * @param svResult
 *   Receives a string result when nInfo when nInfo gets string data.  
 */
function LONG ComponentSetupTypeGetData(zMedia, rul_setuptype_info szSetupType, NUMBER nInfo, BYREF NUMBER nvResult, BYREF STRING svResult);
private enum rul_setuptype_info {
   SETUPTYPE_INFO_DESCRIPTION
   SETUPTYPE_INFO_DISPLAYNAME
}
/**
 * Selects the specified setup type in the file media library referenced by 
 * szMedia.  You can use ComponentSetupTypeSet to override the selection made 
 * in a setup type dialog such as SdSetupTypeEx.  
 * @param szMedia
 *   The name of the media containing the setup type you are setting.  
 * @param szSetupType
 *   The setup type you are selecting.  
 */
function LONG ComponentSetupTypeSet(STRING szMedia, STRING szSetupType);
/**
 * Retrieves the total size in bytes of the selected components, including 
 * all subcomponents, if specified.  
 * @param szMedia
 *   The name of the media containing the components.  
 * @param szComponent
 *   The name of the component.  Place a null string ("") here to retrieve the 
 *   size of the entire media.  
 * @param bIncludeSubComp
 *   Indicate if you wish to include subcomponents in the size total (TRUE) or 
 *   not (FALSE).  
 * @param bTargetSize
 *   Specify whether you want to retrieve the original (before including in 
 *   library) size (TRUE) or the size inside the file media library (FALSE).  
 */
function LONG ComponentTotalSize(STRING szMedia, STRING szComponent, BOOL bIncludeSubComp, BOOL bTargetSize);
/**
 * Validates the password for a component or for the entire file media 
 * library.  Does not work with script-created components.  
 * @param szMedia
 *   The name of the media.  
 * @param szComponent
 *   The name of the component.  If szComponent is a null string (""), 
 *   validates the password for the file media library.  
 * @param szPassword
 *   The password.  Component passwords are set in the Component Properties 
 *   window.  File media library passwords are set in the Advanced Build Type 
 *   property sheet of the Media Build wizard.  
 */
function LONG ComponentValidate(STRING szMedia, STRING szComponent, STRING szPassword);
/**
 * Adds a statement to the Config.sys file.  You can specify the position of 
 * the statement relative to a reference key, add the statement as the first 
 * or last line of the file, or replace an existing line in the file.  
 * @param szKey
 *   The reference key (statement) you are adding to the Config.sys file.  
 * @param szValue
 *   The value of the reference key you are adding to the Config.sys file.  
 * @param szRefKey
 *   The reference key relative to which you are adding szKey in the Config.sys 
 *   file.  If you enter a null string, the line is added as the first or last 
 *   line in the file depending on the nOptions constant you use.  
 * @param nOptions
 *   Specify whether you are adding the line before or after the line 
 *   containing the reference key, or whether you are replacing an existing 
 *   line.  
 *   <LI>BEFORE
 *   <LI>AFTER
 *   <LI>REPLACE
 */
function LONG ConfigAdd(STRING szKey, STRING szValue, STRING szRefKey, rul_add_where nOptions);
/**
 * Removes all lines containing the reference key you specify in the szKey 
 * parameter.  You must use the ConfigFileLoad function to call the 
 * Config.sys file into memory before calling ConfigDelete.  
 * @param szKey
 *   The reference key that identifies the line or lines you want to delete.  
 *   Common reference keys include HIMEM.SYS, FILES, and STACKS.  
 */
function LONG ConfigDelete(STRING szKey);
/**
 * Loads a copy of the specified Config.sys file into memory so that advanced 
 * configuration file functions can operate on the file.  
 * @param szConfigFile
 *   The fully qualified path and filename of the Config.sys file you are 
 *   loading into memory.  If you enter a null string, InstallShield loads the 
 *   default configuration file.  
 */
function LONG ConfigFileLoad(STRING szConfigFile);
/**
 * Saves the configuration file loaded in memory back to the disk.  Depending 
 * on the value passed in the szBackupFile parameter, ConfigFileSave may also 
 * create a backup of the original (unchanged) configuration file.  
 * @param szBackupFile
 *   The backup filename to use to back up the original file you loaded into 
 *   memory.  This parameter must contain only the filename -- do not include 
 *   path information here.  
 */
function LONG ConfigFileSave(STRING szBackupFile);
/**
 * Searches a batch file for the reference key contained in szRefKey.  If you 
 * specify the RESTART constant in nOptions, the first occurrence of the 
 * reference key's value is returned.  You can find subsequent occurrences of 
 * szRefKey by repeatedly calling this function with nOptions set to 
 * CONTINUE.  
 * @param szRefKey
 *   The reference key you are searching for.  You must use only acceptable 
 *   reference keys.  If the reference key is a filename and you do not specify 
 *   a file extension, all file extensions are included in the search.  
 * @param svResult
 *   ConfigFind returns the value of the reference key that was found in the 
 *   configuration file in svResult.  
 * @param nOptions
 *   Indicate whether to start the search from the beginning of the file, or to 
 *   continue from where the previous search was terminated.  
 *   <LI>RESTART
 *   <LI>CONTINUE
 *   <LI>COMMAND
 */
function LONG ConfigFind(STRING szRefKey, BYREF STRING svResult, rul_command_continue_restart nOptions);
/**
 * Retrieves the fully qualified path and filename of the default Config.sys 
 * file.  InstallShield automatically stores the fully qualified path and 
 * filename of the Config.sys file that executed when the target system was 
 * started.  
 * @param svFileName
 *   ConfigGetFileName returns the fully qualified path and filename of the 
 *   default configuration file in svFileName.  
 */
function LONG ConfigGetFileName(BYREF STRING svFileName);
/**
 * Retrieves a specified integer value from the file loaded in memory.  
 * ConfigGetInt retrieves values from commands that have only one value to 
 * the right of the equal sign.  
 * @param szKey
 *   The reference key of the statement from which you want to retrieve the 
 *   integer value.  
 * @param nvValue
 *   ConfigGetInt returns the integer value of the reference key in nvValue.  
 */
function LONG ConfigGetInt(STRING szKey, BYREF NUMBER nvValue);
/**
 * Moves a line relative to a reference line in a configuration file.  You 
 * can specify whether to move the line before or after the reference line.  
 * You can also move the line to the first or last line position in a file.  
 * @param szMove
 *   The line you are moving as a string.  
 * @param szRefKey
 *   The key that identifies the reference line used to position the line you 
 *   are moving.  
 * @param nOptions
 *   Identify where you want to move the line specified by szMove.  
 *   <LI>BEFORE
 *   <LI>AFTER
 */
function LONG ConfigMove(STRING szMove, STRING szRefKey, rul_before_after nOptions);
private enum rul_before_after {
   BEFORE
   AFTER
}
/**
 * Specifies the fully qualified path and filename of the file you want to 
 * use as the default Config.sys file.  However, you usually do not need to 
 * call this function because InstallShield automatically determines the path 
 * and filename of the default Config.sys file used on the target system.  
 * @param szConfigFile
 *   The fully qualified path and filename of the file you want to use as the 
 *   default Config.sys file.  
 */
function LONG ConfigSetFileName(STRING szConfigFile);
/**
 * Changes a specified integer value in the Config.sys file loaded in memory.  
 * ConfigSetInt sets values for commands that have only one value to the 
 * right of the equal sign (=).  It does not work on a command that has more 
 * than one value.  
 * @param szKey
 *   The reference keyword for the integer value you want to set.  
 * @param nValue
 *   The integer value you want to set.  
 */
function LONG ConfigSetInt(STRING szKey, NUMBER nValue);
/**
 * Copies a specified number of bytes from one string to another string.  You 
 * can specify the offset indexes into the source and destination strings.  
 * \n\n** Not available in Visual C++ Edition ** 
 * @param svDest
 *   The destination string.  
 * @param nIndexDest
 *   The offset index (starting point) in the destination string where the 
 *   bytes are to be added.  The first byte in the string is at position 0.  
 * @param svSrc
 *   The source string.  
 * @param nIndexSrc
 *   The offset index (starting point) in the source string where bytes begin 
 *   to be copied from.  The first byte in the string is at position 0.  
 * @param nCount
 *   The total number of bytes you want to copy from szSrc to svDest.  
 */
function LONG CopyBytes(BYREF STRING svDest, NUMBER nIndexDest, BYREF STRING svSrc, NUMBER nIndexSrc, NUMBER nCount);
/**
 * Copies a file from the source folder to the target folder.  InstallShield 
 * uses the SRCDIR and TARGETDIR system variables as the source and target 
 * paths for the function.  
 * @param szSrcFile
 *   Enter the name of the file you are copying from the source folder (as 
 *   specified by the current value of SRCDIR).  You cannot specify a path in 
 *   this parameter, only the filename.  You can use wild card characters to 
 *   copy groups of files.  
 * @param szTargetFile
 *   Enter the name you are giving to the file you are copying to TARGETDIR.  
 *   If you specify a wild card in szSrcFile, szTargetFile is essentially 
 *   ignored.  You cannot specify a path in this parameter, only the filename.  
 */
function LONG CopyFile(STRING szSrcFile, STRING szTargetFile);
/**
 * Creates one or more subfolders on the target drive.  You can use a path 
 * that contains subfolders on more than one level, such as 
 * C:\PROGRAMS\WINAPPS\MYAPP.  If any subfolder in the path does not exist, 
 * CreateDir creates it.  
 * @param szDirPath
 *   Enter the fully qualified path of the subdirectory(ies) you are creating.  
 */
function LONG CreateDir(STRING szDirPath);
/**
 * Creates a new file.  If a file with the same name exists, CreateFile 
 * overwrites it.  Before you create a new file with CreateFile, you must set 
 * the file mode with OpenFileMode.  
 * @param nvFileHandle
 *   After CreateFile creates the file, it returns the file handle for the new 
 *   file in this parameter.  
 * @param szPath
 *   Enter the fully qualified path of the subfolder where you want to create 
 *   the new file.  
 * @param szFileName
 *   Enter the name of the file you are creating.  
 */
function LONG CreateFile(BYREF NUMBER nvFileHandle, STRING szPath, STRING szFileName);
/**
 * Creates a new folder on the target system.  If the folder already exists, 
 * it is highlighted.  Under Windows 95, the folder is created in the Start 
 * Programs menu.  When creating program groups under Windows NT, call the 
 * ProgDefGroupType function first to establish the group as either COMMON or 
 * PERSONAL.  
 * @param szFolderName
 *   Enter the name of the folder you want to add to the target system.  
 */
function LONG CreateProgramFolder(STRING szFolderName);
/**
 * Creates the registry information specified by one or all registry sets in 
 * the current media.  Registry sets are defined in the Resources pane's 
 * Registry Entries folder.  
 * @param szRegistrySet
 *   Specifies the name of a registry set in the current media.  To create all 
 *   registry sets that are defined in the current media, pass a null string 
 *   ("") in this parameter.  
 */
function LONG CreateRegistrySet(STRING szRegistrySet);
/**
 * Creates the shell objects (folders and shortcuts or groups and icons) that 
 * are specified in the current media.  Shell object are defined in the 
 * Resources pane's Shell Objects folder.  
 * @param szReserved
 *   Enter a null string ("") in this parameter.  No other value is allowed.  
 */
function LONG CreateShellObjects(STRING szReserved);
/**
 * Clears the contents of various controls.  CtrlClear deletes the contents 
 * of a single- or multi-line edit field, static text field, single- or 
 * multi-selection list box, or the edit field of a combo box in a custom 
 * dialog box.  \n\n** Not available in Visual C++ Edition ** 
 * @param szDialogName
 *   The name of the dialog box that contains the control you want to delete.  
 * @param nControlID
 *   The control ID of a valid custom dialog box.  
 */
function LONG CtrlClear(STRING szDialogName, NUMBER nControlID);
/**
 * Fills a list box or a combo box control with a file listing that matches 
 * the specified path or filename in szDir.  You can include names of files, 
 * subfolders, and disk drives in the listing.  The CtrlDir function works 
 * only with custom dialog boxes.  \n\n** Not available in Visual C++ Edition 
 * ** 
 * @param szDialogName
 *   The name of a valid dialog box.  
 * @param nControlID
 *   The resource ID of the list box or combo box control.  
 * @param szDir
 *   The fully qualified path or filename, which may include wild card 
 *   characters.  
 * @param nItems
 *   Specify the type of listing you want to display in the control.  
 *   <LI>DLG_DIR_FILE
 *   <LI>DLG_DIR_DIRECTORY
 *   <LI>DLG_DIR_DRIVE
 */
function LONG CtrlDir(STRING szDialogName, NUMBER nControlID, STRING szDir, rul_dlg_dir nItems);
private enum rul_dlg_dir {
   DLG_DIR_FILE
   DLG_DIR_DIRECTORY
   DLG_DIR_DRIVE
}
/**
 * Retrieves the currently selected item from a single selection list box or 
 * combo box control in a custom dialog box.  Use the CtrlGetMultCurSel 
 * function to retrieve items from multi-selection list boxes.  \n\n** Not 
 * available in Visual C++ Edition ** 
 * @param szDialogName
 *   The name of a valid custom dialog box that contains the item you want to 
 *   retrieve.  
 * @param nControlID
 *   The resource ID of the single selection list box or combo box control.  
 * @param svText
 *   CtrlGetCurSel returns the currently selected item from the control in 
 *   svText.  
 */
function LONG CtrlGetCurSel(STRING szDialogName, NUMBER nControlID, BYREF STRING svText);
/**
 * Retrieves the contents of a multi-line edit field control in a custom 
 * dialog box.  InstallShield places each line of the multi-line edit field 
 * into a valid string list identified by listID.  Use the CtrlGetText 
 * function to retrieve the contents of a single line edit field control.  
 * \n\n** Not available in Visual C++ Edition ** 
 * @param szDialogName
 *   The name of a valid custom dialog box that contains the multi-line edit 
 *   control whose contents you want to retrieve.  
 * @param nControlID
 *   The resource ID of the multi-line edit control.  
 * @param listID
 *   The name of a valid string list where you want to place the lines of the 
 *   edit field.  
 */
function LONG CtrlGetMLEText(STRING szDialogName, NUMBER nControlID, LIST listID);
/**
 * Retrieves the currently selected lines from a multi-selection list box 
 * control.  Each selected line of the multi-selection list box is placed 
 * into a string list identified by listID.  To retrieve selected text from a 
 * single selection list box control, use the CtrlGetCurSel function.  The 
 * CtrlGetMultCurSel function is only for use with custom dialog boxes.  
 * \n\n** Not available in Visual C++ Edition ** 
 * @param szDialogName
 *   The name of a valid custom dialog box that contains the list box control 
 *   whose contents you want to retrieve.  
 * @param nControlID
 *   The resource ID of the multi-line edit control.  
 * @param listID
 *   The name of a valid string list where you want to place the lines of the 
 *   list box.  
 */
function LONG CtrlGetMultCurSel(STRING szDialogName, NUMBER nControlID, LIST listID);
/**
 * Gets the current state of a check box or radio button control from a 
 * custom dialog box.  \n\n** Not available in Visual C++ Edition ** 
 * @param szDialogName
 *   The name of the dialog box that contains the control.  
 * @param nControlID
 *   The resource ID of the check box or radio button control whose state you 
 *   want to retrieve.  
 */
function LONG CtrlGetState(STRING szDialogName, NUMBER nControlID);
/**
 * Retrieves the action performed on a control in a custom dialog box.  For 
 * example, CtrlGetSubCommand can tell you if the user single-clicked or 
 * double-clicked a list box or combo box control.  It can also tell you when 
 * the contents of an edit field have changed.  Advanced developers can use 
 * the CmdGetHwndDlg function to handle additional information.  \n\n** Not 
 * available in Visual C++ Edition ** 
 * @param szDialogName
 *   The name of a valid custom dialog box.  
 */
function LONG CtrlGetSubCommand(STRING szDialogName);
/**
 * Retrieves the text from an edit field, static text field, or button 
 * control of a custom dialog box.  To retrieve the text from multi-line edit 
 * field controls, use the CtrlGetMLEText function.  \n\n** Not available in 
 * Visual C++ Edition ** 
 * @param szDialogName
 *   The name of a valid dialog box that contains the field or control whose 
 *   text you want to retrieve.  
 * @param nControlID
 *   The resource ID of the edit field, static text field, or push button 
 *   control.  
 * @param svText
 *   CtrlGetText returns the text from the control or field in svText.  
 */
function LONG CtrlGetText(STRING szDialogName, NUMBER nControlID, BYREF STRING svText);
/**
 * Places a list of existing program folders in a list box or combo box 
 * control.  The CtrlPGroups function is only for use with custom dialog 
 * boxes.  \n\n** Not available in Visual C++ Edition ** 
 * @param szDialogName
 *   The name of a valid custom dialog box that contains the control you want 
 *   to use.  
 * @param nControlID
 *   The resource ID of a valid list box or combo box control.  
 */
function LONG CtrlPGroups(STRING szDialogName, NUMBER nControlID);
/**
 * Selects all the text in an edit field or the edit field of a combo box.  
 * If the control is a multi-line edit field, this function selects all the 
 * text on all lines.  The CtrlSelectText function is only for use with 
 * custom dialog boxes.  \n\n** Not available in Visual C++ Edition ** 
 * @param szDialogName
 *   The name of a valid dialog box that contains the edit field you want to 
 *   select.  
 * @param nControlID
 *   The resource ID of the edit field or combo box control you want to select.  
 */
function LONG CtrlSelectText(STRING szDialogName, NUMBER nControlID);
/**
 * Searches the specified list or combo box control for a string.  If found, 
 * CtrlSetCurSel selects (highlights) the item.  Use the CtrlSetMultCurSel 
 * function for multi-selection list box and combo box controls.  The 
 * CtrlSetCurSel function is only for use with custom dialog boxes.  \n\n** 
 * Not available in Visual C++ Edition ** 
 * @param szDialogName
 *   The name of a valid custom dialog box that contains the control you want 
 *   to find.  
 * @param nControlID
 *   The resource ID of the control that contains the string you are searching 
 *   for.  
 * @param szText
 *   The string you are searching for.  If CtrlSetCurSel finds the item, it is 
 *   selected (highlighted).  
 */
function LONG CtrlSetCurSel(STRING szDialogName, NUMBER nControlID, STRING szText);
/**
 * Specifies a font for a control in a custom dialog box.  Call CtrlSetFont 
 * from within the case DLG_INIT: section of the dialog box message 
 * processing loop.  \n\n** Not available in Visual C++ Edition ** 
 * @param szDialogName
 *   The name of a valid dialog box.  
 * @param hFont
 *   A valid handle to a font created by the GetFont function.  
 * @param nControlID
 *   The resource ID of the control in the dialog box whose font you want to 
 *   set.  To set the font for all the controls in the dialog box, enter 
 *   ALLCONTROLS in this parameter.  
 */
function LONG CtrlSetFont(STRING szDialogName, HWND hFont, NUMBER nControlID=ALLCONTROLS);
/**
 * Places the contents of a string list into the specified single- or 
 * multi-selection list box or combo box control.  Any pre-existing contents 
 * are replaced with the items contained in listID.  InstallShield places 
 * each element of the string list into each element of the list box or combo 
 * box control.  \n\n** Not available in Visual C++ Edition ** 
 * @param szDialogName
 *   The name of a valid dialog box that contains the list box or combo box.  
 * @param nControlID
 *   The resource ID of the list box or combo box.  
 * @param listID
 *   The name of a valid string list that contains the elements you want to 
 *   copy into the list box or combo box control.  
 */
function LONG CtrlSetList(STRING szDialogName, NUMBER nControlID, LIST listID);
/**
 * Sets the text of a multi-line edit box control.  InstallShield separately 
 * places each string in listID into the multi-line edit box control.  The 
 * CtrlSetMLEText function is only for use with custom dialog boxes.  \n\n** 
 * Not available in Visual C++ Edition ** 
 * @param szDialogName
 *   The name of a valid dialog box.  
 * @param nControlID
 *   The resource ID of the multi-line edit box control in the dialog box.  
 * @param listID
 *   The name of a valid string list that contains the elements you want to 
 *   copy into the multi-line edit control.  
 */
function LONG CtrlSetMLEText(STRING szDialogName, NUMBER nControlID, LIST listID);
/**
 * Searches the specified multi-selection list or combo box control.  If 
 * nSelectFlag is set to TRUE, CtrlSetMultCurSel selects (highlights) the 
 * item when it is found.  The CtrlSetMultCurSel function is only for use 
 * with custom dialog boxes.  \n\n** Not available in Visual C++ Edition ** 
 * @param szDialogName
 *   The name of a valid custom dialog box.  
 * @param nControlID
 *   The resource ID of the multi-selection list box control in the dialog box.  
 * @param szText
 *   The string you are searching for.  
 * @param nSelectFlag
 *   Either TRUE or FALSE, indicating whether you want to highlight an item 
 *   when CtrlSetMultCurSel finds it.  TRUE indicates you want the item 
 *   highlighted.  FALSE indicates you do not want the item highlighted.  
 */
function LONG CtrlSetMultCurSel(STRING szDialogName, NUMBER nControlID, STRING szText, NUMBER nSelectFlag);
/**
 * Sets the current state of a check box or radio button control in a custom 
 * dialog box.  You can set certain characteristics of radio buttons and 
 * check boxes when you create them using a resource or dialog editor.  If 
 * you experience difficulties with the behavior of a button control, check 
 * the characteristics of the control in the editor.  \n\n** Not available in 
 * Visual C++ Edition ** 
 * @param szDialogName
 *   The name of a valid dialog box that contains the check box or radio button 
 *   control.  
 * @param nControlID
 *   The resource ID of the check box or radio button control.  
 * @param nState
 *   Specify the new state of the button control.  
 *   <LI>BUTTON_CHECKED
 *   <LI>BUTTON_UNCHECKED
 */
function LONG CtrlSetState(STRING szDialogName, NUMBER nControlID, rul_button_state nState);
private enum rul_button_state {
   BUTTON_CHECKED
   BUTTON_UNCHECKED
   BUTTON_ENTER
   BUTTON_UNKNOWN
}
/**
 * Sets the text of a single-line edit field, static text field, or button 
 * control in a custom dialog box.  To set the text in multi-line edit 
 * fields, use the CtrlSetMLEText function.  \n\n** Not available in Visual 
 * C++ Edition ** 
 * @param szDialogName
 *   The name of a valid dialog box.  
 * @param nControlID
 *   The resource ID of the single line edit field, static text field, or 
 *   button control in a dialog box you are setting the text for.  
 * @param szText
 *   The text you want to place in the control.  
 */
function LONG CtrlSetText(STRING szDialogName, NUMBER nControlID, STRING szText);
/**
 * Registers a custom dialog with InstallShield when you need more control 
 * than that offered by the EzDefineDialog function.  DefineDialog does not 
 * display the dialog.  The dialog is displayed when you call WaitOnDialog.  
 * Under normal circumstances you can use the EzDefineDialog function in 
 * place of the DefineDialog function.  \n\n** Not available in Visual C++ 
 * Edition ** 
 * @param szDialogName
 *   The name of the custom dialog you want to register.  The dialog's name is 
 *   case-sensitive -- you must use it exactly as you specify in this 
 *   parameter.  
 * @param hInstance
 *   The Windows' instance.  In most cases, you can enter zero in this 
 *   parameter.  To obtain the hInstance from a DLL, call the Microsoft Windows 
 *   API LoadLibrary.  
 * @param szDLLName
 *   The fully qualified path and filename of the DLL that contains the dialog 
 *   resource.  Advanced developers specifying their own instance using the 
 *   hInstance parameter enter a null string here.  
 * @param nDialog
 *   The dialog's resource ID if you use a number to identify the resource 
 *   (rather than a string).  This parameter is used only when szDialog is a 
 *   null string ("").  
 * @param szDialog
 *   The dialog's resource ID if you use a string to identify the resource 
 *   (rather than a number).  If this parameter is a null string, InstallShield 
 *   uses nDialog to identify the dialog resources.  
 * @param nReserved
 *   Enter 0 (zero) in this parameter.  No other value is allowed.  
 * @param hwndOwner
 *   The window handle of the owner.  InstallShield uses the HWND_INSTALL 
 *   constant to set the owner of the dialog to the InstallShield main window.  
 * @param lStyle
 *   The level of control you want when responding to dialog box commands.  In 
 *   most cases, use the DLG_MSG_STANDARD constant here.  
 *   <LI>DLG_MSG_STANDARD
 *   <LI>DLG_CENTERED
 */
function LONG DefineDialog(STRING szDialogName, HWND hInstance, STRING szDLLName, NUMBER nDialog, STRING szDialog, NUMBER nReserved, HWND hwndOwner, rul_dialog_style lStyle);
private enum rul_dialog_style {
   DLG_MSG_STANDARD
   DLG_CENTERED
}
/**
 * Specifies a reference file to be checked before the uninstallation process 
 * begins.  If the file is in use, uninstallation will not proceed.  The end 
 * user must close the application that is using this file and start 
 * uninstallation again.  
 * @param szReferenceFile
 *   Enter the fully-qualified name of the file to be checked by 
 *   unInstallShield before uninstallation begins.  This file can be either an 
 *   EXE or a DLL that only the application to be uninstalled uses.  
 */
function LONG DeinstallSetReference(STRING szReferenceFile);
/**
 * Enables unInstallShield functionality.  DeinstallStart creates the 
 * application uninstallation key and initializes creation of or appending to 
 * the uninstall log file.  
 * @param szDefLogPath
 *   Enter the fully qualified path where you want the log file to reside.  
 *   InstallShield will create the filename and append it to the path you 
 *   provide.  If the path does not exist, it is created for you when possible.  
 * @param svLogFile
 *   If svLogfile is a null string, InstallShield creates a new uninstall log 
 *   file.  If you provide the name of a valid existing log file, InstallShield 
 *   will append to it.  
 * @param szKey
 *   Enter the name of the application uninstallation key to be created.  
 * @param lStyle
 *   Enter zero in this parameter.  No other value is allowed.  
 */
function LONG DeinstallStart(STRING szDefLogPath, BYREF STRING svLogFile, STRING szKey, LONG lStyle);
/**
 * Delays the execution of the setup script by a specified number of seconds.  
 * Other tasks running simultaneously with InstallShield proceed normally 
 * while InstallShield is delayed.  
 * @param nSeconds
 *   Enter the number of seconds you want to delay program execution.  
 */
function LONG Delay(NUMBER nSeconds);
/**
 * Deletes a subfolder.  Depending on the value you use in the nFlag 
 * parameter, you can delete a subfolder only if it is empty, delete a 
 * subfolder even if it contains files, or delete an entire root folder.  Set 
 * the nFlag parameter with extreme caution.  
 * @param szDir
 *   Enter the path and the name of the folder you want to delete.  
 * @param nFlag
 *   Specify what you want the function to delete.  
 *   <LI>ALLCONTENTS
 *   <LI>ONLYDIR
 *   <LI>ROOT
 */
function LONG DeleteDir(STRING szDir, rul_DeleteDir_flags nFlag);
private enum rul_DeleteDir_flags {
   ALLCONTENTS
   ONLYDIR
   ROOT
}
/**
 * Deletes one or more files in the target folder.  The system variable 
 * TARGETDIR contains the target folder.  DeleteFile cannot delete read-only, 
 * hidden, or system files.  This function may not work if you try to delete 
 * files on a network system without the appropriate file-deletion rights.  
 * @param szFile
 *   Enter the filename of the file(s) you want to delete.  You must use the 
 *   TARGETDIR system variable to tell DeleteDir the target folder path.  Use 
 *   wild card characters to delete more than one file.  
 */
function LONG DeleteFile(STRING szFile);
/**
 * Removes a program icon from a folder.  
 * @param szProgramFolder
 *   Enter the name of the folder that contains the icon you want to remove.  
 * @param szItemName
 *   Enter the name of the icon you want to delete.  
 */
function LONG DeleteFolderIcon(STRING szProgramFolder, STRING szItemName);
/**
 * Deletes a program folder and its contents, including all folders that 
 * reside under the specified folder.  It cannot delete the Programs folder.  
 * @param szFolderName
 *   Enter the name of the folder you want to remove.  
 */
function LONG DeleteProgramFolder(STRING szFolderName);
/**
 * Changes certain elements of some script dialog (Sd) boxes.  It can change 
 * the bitmap image displayed in the dialog, the style of check box used, and 
 * the units for displaying available hard drive space.  \n\n** Not available 
 * in Visual C++ Edition ** 
 * @param nInfoType
 *   Specifies the type of dialog information to be set.  
 *   <LI>DLG_INFO_USEDECIMAL
 *   <LI>DLG_INFO_KUNITS
 *   <LI>DLG_INFO_ALTIMAGE
 *   <LI>DLG_INFO_CHECKSELECTION
 * @param szInfoString
 *   This string points to the alternate bitmap image used when 
 *   DLG_INFO_ALTIMAGE is used.  
 * @param nParameter
 *   This parameter works with the nInfoType parameter to control various 
 *   aspects of the dialog.  
 *   <LI>CHECKBOX
 *   <LI>CHECKBOX95
 *   <LI>CHECKLINE
 *   <LI>CHECKMARK
 *   <LI>TRUE
 *   <LI>FALSE
 *   <LI>-1
 */
function LONG DialogSetInfo(rul_dialog_info_flags nInfoType, STRING szInfoString, rul_DialogSetInfo_flags nParameter);
private enum rul_dialog_info_flags {
   DLG_INFO_USEDECIMAL
   DLG_INFO_KUNITS
   DLG_INFO_ALTIMAGE
   DLG_INFO_CHECKSELECTION
   DLG_INFO_CHECKMETHOD;
   DLG_INFO_ENABLEIMAGE;
}
private enum rul_DialogSetInfo_flags {
   CHECKBOX
   CHECKBOX95
   CHECKLINE
   CHECKMARK
   TRUE
   FALSE
   -1
}
/**
 * Disables specific user interface objects, graphical capabilities, or 
 * functionality in the setup program.  When you disable a user interface 
 * object, it is either not visible or is grayed out.  
 * @param nConstant
 *   Specify the object or event you want to disable.  
 *   <LI>BACKBUTTON
 *   <LI>BACKGROUND
 *   <LI>BACKGROUNDCAPTION
 *   <LI>BITMAP256COLORS
 *   <LI>CANCEL
 *   <LI>DIALOGCACHE
 *   <LI>FEEDBACK_FULL
 *   <LI>HOURGLASS
 *   <LI>INDVFILESTATUS
 *   <LI>LOGGING
 *   <LI>NEXTBUTTON
 *   <LI>SELFREGISTERBATCH
 *   <LI>STATUS
 */
function LONG Disable(rul_Disable_option nConstant);
private enum rul_Disable_option {
   BACKBUTTON
   BACKGROUND
   BACKGROUNDCAPTION
   BITMAP256COLORS
   CANCEL
   DIALOGCACHE
   FEEDBACK_FULL
   FEEDBACK_SPACE
   FEEDBACK_OPERATION
   HOURGLASS
   INDVFILESTATUS
   LOGGING
   NEXTBUTTON
   SELFREGISTERBATCH
   STATUS
}
/**
 * Executes the currently defined EXIT and HELP handlers.  The Do function 
 * gives you greater control over launching Help- and Exit-related events, 
 * which normally rely upon the user pressing the F1 key (HELP), the F3 key 
 * (EXIT), or the Cancel push button (EXIT).  
 * @param nOperation
 *   Specify the type of operation you want to perform.  
 *   <LI>EXIT
 *   <LI>HELP
 *   <LI>SELFREGISTRATIONPROCESS
 */
function LONG Do(rul_Do_option nOperation);
private enum rul_Do_option {
   EXIT
   HELP
   SELFREGISTRATIONPROCESS
}
/**
 * Launches another setup script.  The new session runs at the same time as 
 * the currently running script.  \n\n** Not available in Visual C++ Edition 
 * ** 
 * @param szInsFile
 *   The fully qualified path and filename of the .ins compiled script file you 
 *   want to launch.  
 * @param szCmdLine
 *   A string containing an InstallShield command line.  You can specify any 
 *   valid startup InstallShield command line here.  
 * @param lWait
 *   Indicate whether or not you want your setup script to wait for the the 
 *   called setup script to complete before continuing.  
 *   <LI>NOWAIT
 *   <LI>WAIT
 */
function LONG DoInstall(STRING szInsFile, STRING szCmdLine, rul_wait_or_nowait lWait);
private enum rul_wait_or_nowait {
   NOWAIT
   WAIT
}
/**
 * Individually enables specific user interface objects, graphical 
 * capabilities, or functionality.  When you enable a user interface object, 
 * it appears.  You can enable a user interface object at any point in the 
 * script.  
 * @param nConstant
 *   Specify the object or event you want to enable.  
 *   <LI>BACKBUTTON
 *   <LI>BACKGROUND
 *   <LI>BACKGROUNDCAPTION
 *   <LI>BITMAP256COLORS
 *   <LI>CORECOMPONENTHANDLING
 *   <LI>DEFWINDOWMODE
 *   <LI>DIALOGCACHE
 *   <LI>FULLWINDOWMODE
 *   <LI>HOURGLASS
 *   <LI>INDVFILESTATUS
 *   <LI>LOGGING
 *   <LI>NEXTBUTTON
 *   <LI>SELFREGISTERBATCH
 *   <LI>STATUS
 *   <LI>STATUSDLG
 *   <LI>STATUSOLD
 */
function LONG Enable(rul_Enable_option nConstant);
private enum rul_Enable_option {
   BACKBUTTON
   BACKGROUND
   BACKGROUNDCAPTION
   BITMAP256COLORS
   CORECOMPONENTHANDLING
   DEFWINDOWMODE
   DIALOGCACHE
   FULLWINDOWMODE
   HOURGLASS
   INDVFILESTATUS
   LOGGING
   NEXTBUTTON
   SELFREGISTERBATCH
   STATUS
   STATUSDLG
   STATUSOLD
}
/**
 * Closes a custom dialog box.  It removes the dialog box and initiates the 
 * dialog closing process.  \n\n** Not available in Visual C++ Edition ** 
 * @param szDialogName
 *   The name of a valid dialog box you want to close.  
 */
function LONG EndDialog(STRING szDialogName);
/**
 * Displays a dialog box that prompts you to insert the next disk.  EnterDisk 
 * recognizes the correct disk by searching the disk for a tag file 
 * (szTagFile).  If the disk does not contain the tag file, an error message 
 * prompts the user to enter the correct disk.  
 * @param szMsg
 *   The message that prompts the user to insert the proper disk.  
 * @param szTagFile
 *   The name of the tag file expected on the inserted disk.  If the file is 
 *   not found, a message is displayed that asks the user to insert the correct 
 *   disk.  
 */
function LONG EnterDisk(STRING szMsg, STRING szTagFile);
/**
 * Checks for the existence of a specified folder on the target system.  
 * @param szPath
 *   Enter the fully qualified path of the folder you are looking for on the 
 *   target system.  
 */
function LONG ExistsDir(STRING szPath);
/**
 * Checks for the existence of a specified disk drive on the target system.  
 * @param szDisk
 *   Enter the letter of the disk you are checking for.  
 */
function LONG ExistsDisk(STRING szDisk);
/**
 * Exits a shell that was launched as a secondary shell during the setup.  
 * ExitProgMan is for use only on Windows 3.1 and Windows NT 3.5 systems.  
 * @param bSaveGroup
 *   Specify whether you want the Program Manager to save its group information 
 *   when the program exits.  
 *   <LI>TRUE
 *   <LI>FALSE
 */
function LONG ExitProgMan(BOOL bSaveGroup);
/**
 * Modifies the PATH statement in the default Autoexec.bat file by adding a 
 * subfolder.  You can also use EzBatchAddPath to modify other environment 
 * variables.  
 * @param szKey
 *   The name of the environment variable you want to modify.  For example, if 
 *   you are modifying the PATH statement, enter "PATH" here.  
 * @param szPath
 *   The subfolder you are adding to the environment variable.  
 * @param szRefDir
 *   The reference key relative to which you are adding the subfolder in 
 *   szPath.  If this is a null string, the subfolder is added as the first or 
 *   last subfolder in the path statement, depending on the value you enter in 
 *   nPosition.  
 * @param nPosition
 *   Specify where to add the subfolder in the environment variable statement.  
 *   The values of szRefDir and nPosition work together to specify where the 
 *   subfolder is added.  
 *   <LI>BEFORE
 *   <LI>AFTER
 */
function LONG EzBatchAddPath(STRING szKey, STRING szPath, STRING szRefDir, rul_before_after nPosition);
/**
 * Adds a line of text to the default Autoexec.bat file.  Specify the 
 * position of the line you are adding in reference to another statement in 
 * the file.  
 * @param szLine
 *   The line of text you want to add to the file.  
 * @param szRefKey
 *   The reference key relative to which you want to add szLine in the 
 *   Autoexec.bat file.  
 * @param nOptions
 *   EzBatchAddString searches the batch file for the reference key and places 
 *   the contents of szLine before or after the line containing the reference 
 *   key depending on the constant you enter in the nOptions parameter.  
 *   <LI>BEFORE
 *   <LI>AFTER
 *   <LI>COMMAND
 *   <LI>REPLACE
 */
function LONG EzBatchAddString(STRING szLine, STRING szRefKey, rul_EzBatchAddString_option nOptions);
private enum rul_EzBatchAddString_option {
   BEFORE
   AFTER
   REPLACE
   COMMAND
}
/**
 * Replaces an existing line of text in the default Autoexec.bat file.  
 * @param szNewString
 *   The new string you are inserting to replace an existing line in the file.  
 */
function LONG EzBatchReplace(STRING szNewString);
/**
 * Adds a device driver statement to the default Config.sys file.  You can 
 * specify the position of the device statement relative to another device 
 * driver.  
 * @param szDriver
 *   The fully qualified path and name of the driver you want to add to the 
 *   file.  If the driver already exists in one or more places in the 
 *   configuration file, this function replaces only the last occurrence of the 
 *   line containing the driver.  
 * @param szRefKey
 *   The name of the device driver relative to which you are adding szDriver.  
 * @param nPosition
 *   Specify if you want szDriver added before or after the szRefKey.  
 *   <LI>BEFORE
 *   <LI>AFTER
 */
function LONG EzConfigAddDriver(STRING szDriver, STRING szRefKey, rul_before_after nPosition);
/**
 * Adds a line of text to the default Config.sys file.  You can specify the 
 * position of the line you add in reference to another statement in the 
 * file.  
 * @param szLine
 *   The line of text you want to add to the Config.sys file.  
 * @param szRefKey
 *   The reference key relative to which you want to position szLine in the 
 *   Config.sys file.  
 * @param nOptions
 *   Specify whether you want szLine placed before or after the line containing 
 *   szRefKey.  
 *   <LI>BEFORE
 *   <LI>AFTER
 */
function LONG EzConfigAddString(STRING szLine, STRING szRefKey, rul_before_after nOptions);
/**
 * Retrieves the numeric value of a parameter from the default Config.sys 
 * file.  You can use EzConfigGetValue to retrieve the values of parameters 
 * such as FILES and BUFFERS.  
 * @param szRefKey
 *   The name of the parameter whose value you are retrieving.  
 * @param nvValue
 *   EzConfigGetValue returns the numeric value in nvValue.  
 */
function LONG EzConfigGetValue(STRING szRefKey, BYREF NUMBER nvValue);
/**
 * Sets the value of a command in the Config.sys file.  EzConfigSetValue 
 * automatically determines the Config.sys file used at bootup time and makes 
 * the appropriate modifications.  InstallShield automatically determines the 
 * fully qualified path and filename of the default Config.sys file.  
 * @param szRefKey
 *   The command whose value you want to change or add in the Config.sys file.  
 *   If InstallShield cannot find the key in the Config.sys file, it is added 
 *   for you.  
 * @param nValue
 *   The new value of szRefKey you want to set.  
 */
function LONG EzConfigSetValue(STRING szRefKey, NUMBER nValue);
/**
 * Defines a dialog to InstallShield.  Use EzDefineDialog in place of 
 * DefineDialog when the DefineDialog function's added capability is not 
 * needed.  \n\n** Not available in Visual C++ Edition ** 
 * @param szDialogName
 *   A unique name for the dialog.  InstallShield uses this name to identify 
 *   and register the dialog in the script.  
 * @param szDLL
 *   The fully qualified name of the DLL that contains the dialog box you are 
 *   registering.  If you enter a null string (""), InstallShield will look in 
 *   _ISUSER.DLL and _ISRES.DLL for the dialog.  
 * @param szID
 *   The name (identifier) of the dialog box.  Enter the string identifier 
 *   only.  If the dialog box has a numeric identifier, enter a null string 
 *   ("") in this parameter.  
 * @param nID
 *   The numeric identifier of the dialog box.  Only enter the numeric 
 *   identifier.  If the dialog box has a string identifier, enter zero in this 
 *   parameter.  
 */
function LONG EzDefineDialog(STRING szDialogName, STRING szDLL, STRING szID, NUMBER nID);
/**
 * Compares the size, dates, or versions of two files.  \n\n** Not available 
 * in Visual C++ Edition ** 
 * @param szFileName1
 *   The name of the first file you want to compare.  InstallShield uses the 
 *   SRCDIR system variable as the path of the file.  
 * @param szFileName2
 *   The name of the second file you want to compare.  InstallShield uses the 
 *   TARGETDIR system variable as the path of the file.  
 * @param nCompareFlag
 *   Specify the options you want to include in the comparison.  
 *   <LI>COMPARE_SIZE
 *   <LI>COMPARE_DATE
 *   <LI>COMPARE_VERSION
 */
function LONG FileCompare(STRING szFileName1, STRING szFileName2, rul_FileCompare_option nCompareFlag);
private enum rul_FileCompare_option {
   COMPARE_SIZE
   COMPARE_DATE
   COMPARE_VERSION
}
/**
 * Deletes a range of lines (including the starting line and ending line) 
 * from a text file using a starting and ending line number.  This function 
 * works on line-oriented text files with lines whose length is less than 512 
 * bytes (Windows 3.1) or 1,024 bytes (Windows NT 3.5 and Windows 95).  
 * FileDeleteLine will not work with binary files.  \n\n** Not available in 
 * Visual C++ Edition ** 
 * @param szFileName
 *   The name of the file that contains the lines you want to delete.  
 *   InstallShield uses the SRCDIR system variable as the path of the file.  
 * @param nStartLineNum
 *   The number of the first line you want to delete.  
 * @param nEndLineNum
 *   The number of the last line for deletion.  You can set this parameter to 
 *   DELETE_EOF.  This action causes InstallShield to delete from nStartLineNum 
 *   to the end of the file.  
 */
function LONG FileDeleteLine(STRING szFileName, NUMBER nStartLineNum, NUMBER nEndLineNum);
/**
 * Searches a file for the specified string.  If found, the entire line and 
 * the line number are returned.  The search is not case-sensitive.  FileGrep 
 * works on line-oriented text files with lines whose length is less than 512 
 * bytes (Windows 3.1) or 1,024 bytes (Windows NT 3.5 and Windows 95).  
 * FileGrep will not work with binary files.  \n\n** Not available in Visual 
 * C++ Edition ** 
 * @param szFileName
 *   The name of the file you want to search.  InstallShield uses the SRCDIR 
 *   system variable as the path of the file.  
 * @param szSearchStr
 *   The string you are searching for in the file.  
 * @param svReturnLine
 *   FileGrep uses svReturnLine to return the line where szSearchStr was found.  
 * @param nvLineNumber
 *   FileGrep uses nvLineNumber to return the line number where szSearchStr was 
 *   found.  Line numbering starts on line 0.  
 * @param nFlag
 *   Specify the flag you want to set.  
 *   <LI>CONTINUE
 *   <LI>RESTART
 */
function LONG FileGrep(STRING szFileName, STRING szSearchStr, BYREF STRING svReturnLine, BYREF NUMBER nvLineNumber, rul_continue_restart nFlag);
private enum rul_continue_restart {
   CONTINUE
   RESTART
}
/**
 * Inserts or replaces a line using line numbers.  You can use FileInsertLine 
 * with FileGrepFileGrep, which finds lines and returns their line numbers.  
 * FileInsertLine works on line-oriented text files with lines with a length 
 * less than 512 bytes (Windows 3.x) or 1,024 bytes (Windows NT and Windows 
 * 95).  \n\n** Not available in Visual C++ Edition ** 
 * @param szFileName
 *   The name of the file you want to insert szInsertLine into.  FileInsertLine 
 *   uses the SRCDIR system variable as the path of the file.  
 * @param szInsertLine
 *   The string you are inserting into the file.  
 * @param nLineNumber
 *   The line number where you want to insert szInsertLine.  The first possible 
 *   line number is 0.  
 * @param nInsertFlag
 *   Specify where you want to place szInsertLine.  
 *   <LI>BEFORE
 *   <LI>AFTER
 *   <LI>APPEND
 *   <LI>REPLACE
 */
function LONG FileInsertLine(STRING szFileName, STRING szInsertLine, NUMBER nLineNumber, rul_insert_flags nInsertFlag);
private enum rul_insert_flags {
   BEFORE
   AFTER
   REPLACE
   APPEND
}
/**
 * Searches an entire disk or folder structure and returns a string list of 
 * subfolder names.  If nOp is INCLUDE_SUBDIR, the search starts at the 
 * folder specified by szDir and continues searching the subfolder structure.  
 * @param szDir
 *   The name of the folder where you want to begin the search.  
 * @param nOp
 *   Specify if you want the subfolders of szDir included in the list.  
 *   <LI>EXCLUDE_SUBDIR
 *   <LI>INCLUDE_SUBDIR
 * @param listDirs
 *   The name of a valid string list where the folder names will be placed.  
 */
function LONG FindAllDirs(STRING szDir, rul_yesno_subdir nOp, LIST listDirs);
private enum rul_yesno_subdir {
   INCLUDE_SUBDIR
   EXCLUDE_SUBDIR
}
/**
 * Searches an entire subfolder structure and returns the name of the first 
 * file with a particular file specification.  If the argument passed to nOp 
 * is RESET, InstallShield starts searching at the folder specified in the 
 * szDir parameter and continues searching the subfolder structure until it 
 * finds a file matching szFileName.  If nOp equals CONTINUE, the search 
 * continues where it left off the last time the function was called.  
 * @param szDir
 *   Enter the name of the folder where you want to start searching for the 
 *   files.  
 * @param szFileName
 *   Enter the file specification you want to search for.  You can use wild 
 *   card characters in this parameter.  
 * @param svResult
 *   InstallShield sets this parameter to the fully qualified path of the first 
 *   matching file it found.  If the function fails, InstallShield does not 
 *   alter this parameter.  
 * @param nOp
 *   Specify whether you want the search to start at the beginning of the 
 *   folder in szDir or if you want it to resume from the point where it 
 *   stopped after a previous search.  
 *   <LI>CONTINUE
 *   <LI>RESET
 */
function LONG FindAllFiles(STRING szDir, STRING szFileName, BYREF STRING svResult, rul_command_reset nOp);
private enum rul_command_reset {
   COMMAND
   RESET
}
/**
 * Searches a subfolder for a specified file.  InstallShield returns the 
 * first file that matches the file specification in the svResult parameter.  
 * @param szPath
 *   Enter the name of the subfolder you want to search.  Only the subfolder 
 *   you specify in this parameter is searched.  
 * @param szFileName
 *   Enter the name of the file you want to search for.  You can use wild card 
 *   characters in this parameter.  
 * @param svResult
 *   Returns the name of the first file that matches szFileName.  This 
 *   parameter contains the filename only -- it does not contain the path of 
 *   the file.  
 */
function LONG FindFile(STRING szPath, STRING szFileName, BYREF STRING svResult);
/**
 * Gets a handle to a window that you specify by window class and window 
 * name.  If you know the class and window name of an application, you can 
 * get its handle.  You can use the window handle to send messages directly 
 * to the window.  FindWindow is for advanced developers.  \n\n** Not 
 * available in Visual C++ Edition ** 
 * @param szClassName
 *   The name of the class to which the window belongs.  
 * @param szWinName
 *   The Window caption (title) whose handle you want to retrieve.  
 */
function LONG FindWindow(STRING szClassName, STRING szWinName);
/**
 * Gets the name of a folder, including the filename, if applicable, from a 
 * specified full path.  GetDir extracts the folder path and the filename and 
 * discards the drive letter.  The function does return the initial 
 * backslash.  
 * @param szPath
 *   Enter the fully qualified path that you want to extract the folder from.  
 * @param svDir
 *   Returns the path and filename, less the drive letter.  
 */
function LONG GetDir(STRING szPath, BYREF STRING svDir);
/**
 * Extracts the disk drive letter and colon from a fully qualified path and 
 * filename, if included.  
 * @param szPath
 *   Enter the full path (including the colon) that contains the drive letter 
 *   you want.  
 * @param svDisk
 *   Returns the drive letter, including the colon.  
 */
function LONG GetDisk(STRING szPath, BYREF STRING svDisk);
/**
 * Determines how much free disk space is available on a particular drive.  
 * The maximum value returned is 2 GB.  Free disk space greater than that 
 * still returns as 2 GB.  
 * @param szDrive
 *   Enter the letter of the drive you want to check, including the colon.  
 *   Even if szDrive is only a drive letter and not a path, it still must 
 *   include a colon.  
 */
function LONG GetDiskSpace(STRING szDrive);
/**
 * Retrieves the current value of an environment variable.  
 * @param szParameter
 *   Enter the name of the variable you want to retrieve a value for.  
 * @param svValue
 *   Returns the current value of the environment variable.  
 */
function LONG GetEnvVar(STRING szParameter, BYREF STRING svValue);
/**
 * Retrieves the dimensions of a screen in pixels.  This function returns the 
 * width of the screen, in pixels, in the nvDx parameter, and the height, in 
 * pixels, in the nvDy parameter.  For example, a standard VGA monitor 
 * returns 640 in nvDx and 480 in nvDy.  
 * @param nvDx
 *   Returns the width of the screen in pixels.  
 * @param nvDy
 *   Returns the height of the screen in pixels.  
 */
function LONG GetExtents(BYREF NUMBER nvDx, BYREF NUMBER nvDy);
/**
 * Retrieves the access rights, date, time, and/or size information from a 
 * file.  In each GetFileInfo statement, you can ask for only one of these 
 * items of data.  For example, to get the date and time information for a 
 * file, type one GetFileInfo call asking for the date, and a second asking 
 * for the time.  
 * @param szPathName
 *   Enter the fully qualified path and name of the file for which you want to 
 *   retrieve the information.  
 * @param nType
 *   Specify what type of file information you want.  If the information you 
 *   want is a number, GetFileInfo places it in nvResult.  If the information 
 *   is a string, GetFileInfo places it in svResult.  
 *   <LI>FILE_ATTRIBUTE
 *   <LI>FILE_DATE
 *   <LI>FILE_SIZE
 *   <LI>FILE_TIME
 * @param nvResult
 *   If the information you request is a number, it appears in this variable.  
 * @param svResult
 *   If you ask for the time or date, they appear as string values in svResult.  
 *   Time is returned as HH:MM:SS.  The date is returned as YYYY\MM\DD.  
 */
function LONG GetFileInfo(STRING szPathName, rul_FileInfo_flags nType, BYREF NUMBER nvResult, BYREF STRING svResult);
private enum rul_FileInfo_flags {
   FILE_ATTRIBUTE
   FILE_DATE
   FILE_SIZE
   FILE_TIME
}
/**
 * Retrieves a list of program item shortcuts and a list of subfolder names 
 * from a specified folder.  GetFolderNameList is recommended for use with 
 * Windows NT version 4.0 and Windows 95.  Under Windows 3.x and Windows NT 
 * 3.51, GetFolderNameList returns listItemsID but ignores listSubFoldersID.  
 * On Windows NT, call ProgDefGroupType first to establish the group as 
 * either COMMON or PERSONAL.  By default, InstallShield searches under 
 * COMMON.  
 * @param szFolderName
 *   The name of the folder to be queried.  
 *   <LI>szFolderName
 *   <LI>FOLDER_DESKTOP
 *   <LI>FOLDER_STARTMENU
 *   <LI>FOLDER_STARTUP
 * @param listItemsID
 *   Returns a list with the names of the program items in szFolderName.  
 * @param listSubFoldersID
 *   Returns a list with the names of the subfolders in szFolderName.  
 */
function LONG GetFolderNameList(rul_folder_name szFolderName, LIST listItemsID, LIST listSubFoldersID);
private enum rul_folder_name {
   FOLDER_DESKTOP
   FOLDER_STARTMENU
   FOLDER_STARTUP
}
/**
 * Builds a font and retrieves its handle.  You can use the font handle to 
 * specify the font used by the controls in a custom dialog box.  
 * @param szFontName
 *   The font face name you want to build.  
 * @param nPointSize
 *   The point size of the font you want to build.  
 * @param nAttributes
 *   Specify the style of the font you are building.  You can combine style 
 *   options using the bitwise OR operator ( | ).  
 *   <LI>STYLE_BOLD
 *   <LI>STYLE_ITALIC
 *   <LI>STYLE_NORMAL
 *   <LI>STYLE_UNDERLINE
 */
function LONG GetFont(STRING szFontName, NUMBER nPointSize, rul_font_style nAttributes);
private enum rul_font_style {
   STYLE_BOLD
   STYLE_ITALIC
   STYLE_NORMAL
   STYLE_UNDERLINE
}
/**
 * Retrieves all the program folder names that currently exist in the shell.  
 * GetGroupNameList returns the folder names in the form of a list.  If the 
 * target system has a shell other than the Windows 95 shell or Program 
 * Manager, this function may return an error.  
 * @param listID
 *   The name of a valid string list.  InstallShield places a folder name in 
 *   each element of this list.  
 */
function LONG GetGroupNameList(LIST listID);
/**
 * Retrieves all the program items from a specified program folder.  If the 
 * target system has a shell other than the Windows 95 shell or Program 
 * Manager, this function may return an error.  
 * @param szGroup
 *   The name of the folder whose program items you want to retrieve.  
 * @param listID
 *   The name of a valid string list.  InstallShield uses this list to return 
 *   the names of each program icons in the folder defined in szGroup.  
 */
function LONG GetItemNameList(STRING szGroup, LIST listID);
/**
 * Reads a line of text from an open text file.  Before you can use GetLine, 
 * you must open the file using the OpenFile function.  The first time you 
 * use GetLine it reads the first line of text from the file.  After reading 
 * a line, GetLine repositions the file pointer to the next line.  The second 
 * time you use GetLine, it reads the second line, and so forth.  GetLine 
 * strips the carriage return and line feed characters from the end of the 
 * line it returns.  
 * @param nvFileHandle
 *   Enter the name of the handle that opens the file.  
 * @param svLine
 *   Enter a string variable large enough to hold the lines of text you are 
 *   receiving.  
 */
function LONG GetLine(BYREF NUMBER nvFileHandle, BYREF STRING svLine);
/**
 * Determines how much memory is available to an application running under 
 * Microsoft Windows.  Because Microsoft Windows is a virtual memory system, 
 * this function does not return the actual physical memory (called RAM), but 
 * the memory available to a Windows application.  Use the GetSystemInfo 
 * function to determine the amount of actual physical memory available on 
 * the target system.  
 *   No parameters.  
 */
function LONG GetMemFree();
/**
 * Determines if Microsoft Windows is running in standard mode or enhanced 
 * mode.  You can also use the GetSystemInfo function to retrieve the version 
 * of Windows on the target system.  
 *   No parameters.  
 */
function LONG GetMode();
/**
 * Retrieves a profile string from the specified INI file.  GetProfInt works 
 * like the Windows API GetPrivateProfileString.  \n\n** Not available in 
 * Visual C++ Edition ** 
 * @param szFileName
 *   The name of the INI file you want to search that contains szSectionName 
 *   and szKeyName.  If you do not specify a path, InstallShield searches for 
 *   the INI file in the Windows folder.  
 * @param szSectionName
 *   A string that identifies the section name in the INI file you are 
 *   searching through.  Do not include section name delimiting brackets ( [] 
 *   ).  
 * @param szKeyName
 *   A string that contains the key name identifier you are looking for.  
 * @param nvValue
 *   GetProfInt returns an integer value in nvValue.  The integer can be a 
 *   maximum of 2 bytes in length.  If the integer in the INI file is greater 
 *   than 65,535, GetProfInt cannot return an accurate value.  This is a 
 *   Microsoft Windows system limitation.  
 */
function LONG GetProfInt(STRING szFileName, STRING szSectionName, STRING szKeyName, BYREF NUMBER nvValue);
/**
 * Retrieves a profile string from the specified INI file.  GetProfString 
 * works like the Windows API GetPrivateProfileString.  \n\n** Not available 
 * in Visual C++ Edition ** 
 * @param szFileName
 *   The fully qualified path of the INI file that contains the szSectionName 
 *   and szKeyName you are searching for.  If you do not specify a path in this 
 *   parameter, InstallShield looks for the file in the Windows folder.  
 * @param szSectionName
 *   The name of the application section of the INI file you want to search 
 *   through.  Do not include section name delimiting brackets ( [] ).  
 * @param szKeyName
 *   The name of the key you want to retrieve from the application section.  If 
 *   you enter a null string, InstallShield returns all the application's key 
 *   names (separated by NULL characters) in svResult.  
 * @param svResult
 *   GetProfString returns the value retrieved from the INI file in svResult.  
 */
function LONG GetProfString(STRING szFileName, STRING szSectionName, STRING szKeyName, BYREF STRING svResult);
/**
 * Gets information about the target system.  In each GetSystemInfo function 
 * call, you can only get one piece of information returned.  
 * @param nItem
 *   Specify the information you want to retrieve from the target system.  
 *   <LI>BASEMEMORY
 *   <LI>BOOTUPDRIVE
 *   <LI>CDROM
 *   <LI>COLORS
 *   <LI>CPU
 *   <LI>DATE
 *   <LI>DISK_TOTALSPACE
 *   <LI>DRIVE
 *   <LI>ENVSPACE
 *   <LI>EXTENDEDMEMORY
 *   <LI>FREEENVSPACE
 *   <LI>ISTYPE
 *   <LI>LANGUAGE
 *   <LI>LANGUAGE_DRV
 *   <LI>MOUSE
 *   <LI>MOUSE_DRV
 *   <LI>NETWORK
 *   <LI>NETWORK_DRV
 *   <LI>OS
 *   <LI>OSMAJOR
 *   <LI>OSMINOR
 *   <LI>PARALLEL
 *   <LI>SERIAL
 *   <LI>SHARE
 *   <LI>TIME
 *   <LI>VIDEO
 *   <LI>VOLUMELABEL
 *   <LI>WINMAJOR
 *   <LI>WINMINOR
 *   <LI>WIN32SINSTALLED
 *   <LI>WIN32SMAJOR
 *   <LI>WIN32SMINOR
 * @param nvResult
 *   When the data you want is numeric, GetSystemInfo returns it in this 
 *   parameter.  
 * @param svResult
 *   When the data you want is alphanumeric, GetSystemInfo returns it here.  
 */
function LONG GetSystemInfo(rul_GetSystemInfo_option nItem, BYREF NUMBER nvResult, BYREF STRING svResult);
private enum rul_GetSystemInfo_option {
   BASEMEMORY
   BOOTUPDRIVE
   CDROM
   COLORS
   CPU
   DATE
   DISK_FREESPACE
   DISK_TOTALSPACE
   DRIVE
   ENVSPACE
   EXTENDEDMEMORY
   FREEENVSPACE
   ISTYPE
   LANGUAGE
   LANGUAGE_DRV
   MOUSE
   MOUSE_DRV
   NETWORK
   NETWORK_DRV
   OS
   OSMAJOR
   OSMINOR
   PARALLEL
   SERIAL
   SHARE
   TIME
   VIDEO
   VOLUMELABEL
   WINMAJOR
   WINMINOR
   WIN32SINSTALLED
   WIN32SMAJOR
   WIN32SMINOR
}
/**
 * Retrieves a list of all the drives attached to the target system that meet 
 * a certain criterion.  This criterion includes the type of drive and the 
 * minimum amount of space on the drive.  
 * @param listID
 *   The name of a valid string list.  This list will contain the valid drive 
 *   letters when the function is completed.  
 * @param nDriveType
 *   Specify the type of drive you are searching for.  
 *   <LI>FIXED_DRIVE
 *   <LI>REMOTE_DRIVE
 *   <LI>REMOVEABLE_DRIVE
 *   <LI>CDROM_DRIVE
 * @param nMinDriveSpace
 *   The minimum amount of disk space in bytes that must be free on the drive 
 *   to allow the drive to be included in the return list.  If nMinDriveSpace 
 *   is less than zero, GetValidDrivesList will not check for the minimum space 
 *   on the drive.  
 */
function LONG GetValidDrivesList(LIST listID, rul_drive_type nDriveType, NUMBER nMinDriveSpace);
private enum rul_drive_type {
   FIXED_DRIVE
   REMOTE_DRIVE
   REMOVEABLE_DRIVE
   CDROM_DRIVE
}
/**
 * Gets the handle for the main window of the setup.  
 * @param nHwndFlag
 *   HWND_INSTALL is the only constant available for this parameter.  It 
 *   specifies that you want to retrieve the window handle to InstallShield's 
 *   main window.  
 */
function LONG GetWindowHandle(NUMBER nHwndFlag);
/**
 * Creates custom handlers for events such as the Help accelerator key (F1), 
 * the Cancel push button, and the Exit accelerator key (F3).  
 * @param nObject
 *   Specify the event for which you want to execute a custom handler.  
 *   <LI>EXIT
 *   <LI>HELP
 * @param Label
 *   The name of the label to which you want the program to jump if the 
 *   specified push button or accelerator key is pressed.  Do not define this 
 *   label as a numeric value or as a string variable.  
 */
function LONG Handler(rul_handler_type nObject, STRING szLabel);
private enum rul_handler_type {
   EXIT
   HELP
}
/**
 * Retrieves the high-order word from the 32-bit integer value you specify in 
 * nValue.  
 * @param nValue
 *   The value you want to convert.  
 */
function LONG HIWORD(NUMBER nValue);
/**
 * Specifies a company name, a product name, a product version number, and an 
 * application executable filename.  The information you specify is used to 
 * create an application information key and a per application paths key for 
 * the program you are installing.  
 * @param szCompany
 *   Enter the name of your company.  InstallShield uses szCompany to create a 
 *   \<company> key under the [HKEY_LOCAL_MACHINE]\Software key in the 
 *   registry.  
 * @param szProduct
 *   Enter the name of the product you are installing.  InstallShield uses 
 *   szProduct to create a \<product> key under the 
 *   [HKEY_LOCAL_MACHINE]\Software\<company> registry key.  szProduct is also 
 *   inserted into the welcome dialog box.  
 * @param szVersion
 *   Enter the version number of the product.  InstallShield uses szVersion to 
 *   create a \<version> key under the 
 *   [HKEY_LOCAL_MACHINE]\Software\<company>\<product> key in the registry.  
 * @param szProductKey
 *   Your application's main executable filename.  Used to create a per 
 *   application paths key under 
 *   [HKEY_LOCAL_MACHINE]\Software\Microsoft\Windows\CurrentVersion\App Paths.  
 */
function LONG InstallationInfo(STRING szCompany, STRING szProduct, STRING szVersion, STRING szProductKey);
/**
 * Retrieves commonly needed information for the script.  
 * @param nIsFlag
 *   Specify the type of information you want to retrieve.  You can specify 
 *   only one constant in each Is function call.  
 *   <LI>DIR_WRITEABLE
 *   <LI>FILE_EXISTS
 *   <LI>FILE_LOCKED
 *   <LI>FILE_WRITEABLE
 *   <LI>MATH_COPROCESSOR
 *   <LI>PATH_EXISTS
 *   <LI>USER_ADMINISTRATOR
 *   <LI>VALID_PATH
 *   <LI>WINDOWS_SHARED
 * @param szIsData
 *   The information you pass to this parameter varies depending on the 
 *   constant used in the nIsFlag parameter.  
 */
function LONG Is(rul_is_option nIsFlag, STRING szIsData);
private enum rul_is_option {
   DIR_WRITEABLE
   FILE_EXISTS
   FILE_INSTALLED
   FILE_INVALID
   FILE_IS_LOCKED
   FILE_LOCKED
   FILE_WRITEABLE
   MATH_COPROCESSOR
   PATH_EXISTS
   USER_ADMINISTRATOR
   VALID_PATH
   WINDOWS_SHARED
}
/**
 * Compares the Service Pack number installed on a Windows NT system to the 
 * Service Pack number you pass in the szServicePack parameter.  \n\n** NOTE: 
 * When using ISCompareServicePack, remember to add #include "Sddialog.h" 
 * before the program block and #include "Sddialog.rul" after the endprogram 
 * statement, since this function is defined in Sdint.rul.  If you are using 
 * the Setup.rul generated by the Project Wizard, these lines are already 
 * included.  
 * @param szServicePack
 *   A string with the Service Pack number you want to compare with the target 
 *   WinNT system.  The Service Pack string must be in the format "Service Pack 
 *   n" (case sensitive), where n is the Service Pack number.  
 */
function LONG ISCompareServicePack(STRING szServicePack);
/**
 * Allows you to launch another application program from within the script.  
 * The launched application and the script run simultaneously.  \n\n** Not 
 * available in Visual C++ Edition ** 
 * @param szCommand
 *   Enter the fully qualified path and filename of the application to launch.  
 *   If you do not specify a path, InstallShield searches the current folder, 
 *   the Windows folder, the Windows System folder, and the folders in the PATH 
 *   environment variable.  
 * @param szCmdLine
 *   Enter the command line parameters (if there are any) you want to pass to 
 *   the launched application.  Otherwise, enter a null string.  
 */
function LONG LaunchApp(STRING szCommand, STRING szCmdLine);
/**
 * Launches an application, szProgram, with the command line szCmdLine.  
 * Unlike LaunchApp, this function allows the script to wait at this 
 * statement until the launched application terminates.  \n\n** Not available 
 * in Visual C++ Edition ** 
 * @param szProgram
 *   Enter the fully qualified path and filename of the application launch.  If 
 *   you do not specify the path and filename, InstallShield may not be able to 
 *   launch the application.  
 * @param szCmdLine
 *   Enter the command line parameters you want to pass to the launched 
 *   application.  Otherwise, enter a null string.  Do not enter a string 
 *   literal - use a variable to specify the command line and pass the variable 
 *   in this parameter.  
 * @param lWait
 *   Specify whether or not you want InstallShield to wait for the launched 
 *   application to terminate before it continues with the next line in the 
 *   setup script.  
 *   <LI>NOWAIT
 *   <LI>WAIT
 */
function LONG LaunchAppAndWait(STRING szProgram, STRING szCmdLine, rul_wait_or_nowait lWait);
/**
 * Adds a numeric element to a number list before or after the current 
 * element.  Use the ListGetFirstItem, ListGetNextItem, and ListSetIndex 
 * functions to traverse the list.  
 * @param listID
 *   The name of a valid number list.  
 * @param nItem
 *   The numeric element you want to add to the list.  
 * @param nPlacementFlag
 *   Specifies where to place nItem with respect to the current element.  
 *   <LI>AFTER
 *   <LI>BEFORE
 */
function LONG ListAddItem(LIST listID, NUMBER nItem, rul_before_after nPlacementFlag);
/**
 * Adds a string to a string list before or after the current element.  The 
 * ListGetFirstString, ListGetNextString, and ListSetIndex functions allow 
 * you to traverse the list and make any element the current element.  
 * @param listID
 *   Enter the name of a valid string list.  
 * @param szString
 *   Enter the string you want to add to the list.  
 * @param nPlacementFlag
 *   Specify where you want to put szString with respect to the current 
 *   element.  The string you are adding to the list will go either before or 
 *   after the current element.  
 *   <LI>AFTER
 *   <LI>BEFORE
 */
function LONG ListAddString(LIST listID, STRING szString, rul_before_after nPlacementFlag);
/**
 * Determines how many string or numeric elements a specified list contains.  
 * @param listID
 *   The name of a valid string or number list.  
 */
function LONG ListCount(LIST listID);
/**
 * Builds an empty string or number list.  
 * @param nListType
 *   Specify the type of list you want to build.  
 *   <LI>NUMBERLIST
 *   <LI>STRINGLIST
 */
function LONG ListCreate(rul_list_type nListType);
private enum rul_list_type {
   NUMBERLIST
   STRINGLIST
}
/**
 * Retrieves the current element from the number list you specify in listID.  
 * You can also use the ListGetFirstItem and ListGetNextItem functions to 
 * traverse the list and make any element the current element.  
 * @param listID
 *   Enter the name of a valid number list whose current element you want to 
 *   retrieve.  
 * @param nvItem
 *   Contains the number of the current element in the list returned by the 
 *   function.  
 */
function LONG ListCurrentItem(LIST listID, NUMBER BYREF NUMBER nvItem);
/**
 * Retrieves the current element from the string list you specify in listID.  
 * You can also use the ListGetFirstString and ListGetNextString functions to 
 * traverse the list and make any element the current element.  
 * @param listID
 *   Enter the name of a valid string list whose current element you want to 
 *   retrieve.  
 * @param svString
 *   Contains the number of the current element in the list returned by the 
 *   function.  
 */
function LONG ListCurrentString(LIST listID, BYREF STRING svString);
/**
 * Removes the current element from the number list you specify in listID.  
 * You can also use the ListGetFirstItem and ListGetNextItem functions to 
 * traverse the list and make any element the current element.  
 * @param listID
 *   Enter the name of a valid number list whose current element you want to 
 *   remove.  
 */
function LONG ListDeleteItem(LIST listID);
/**
 * Removes the current element from the string list you specify in listID.  
 * You can also use the ListGetFirstString and ListGetNextString functions to 
 * traverse the list and make any element the current element.  
 * @param listID
 *   Enter the name of a valid string list whose current element you want to 
 *   remove.  
 */
function LONG ListDeleteString(LIST listID);
/**
 * Removes a string or number list you identify in listID.  This function 
 * destroys the contents of the list and the list itself.  Once you destroy a 
 * list, do not use that listID with any list function.  
 * @param listID
 *   Enter the name of the string or number list you want to destroy.  
 */
function LONG ListDestroy(LIST listID);
/**
 * Searches for a specific element in a number list.  This function begins 
 * its search at the current element and continues down through the list from 
 * that point.  If you want to start the search from the beginning of the 
 * list, use the ListGetFirstItem function.  When ListFindItem finds the 
 * element, it becomes the current element in the list.  
 * @param listID
 *   Enter the name of a valid number list whose elements you want to search.  
 * @param nItem
 *   Enter the item you are searching for in the list.  
 */
function LONG ListFindItem(LIST listID, NUMBER nItem);
/**
 * Searches for a specified element in a string list.  This function begins 
 * its search at the current element and continues from that point.  If you 
 * want to start the search from the beginning of the string list, use the 
 * ListGetFirstString function.  When ListFindString finds the string, it 
 * becomes the current element in the list.  This function performs a 
 * case-sensitive comparison of the strings.  
 * @param listID
 *   Enter the name of a valid string list whose elements you want to search.  
 * @param szString
 *   Enter the string you are searching for in the list.  InstallShield 
 *   performs a case-sensitive comparison.  
 */
function LONG ListFindString(LIST listID, STRING szString);
/**
 * Retrieves the first element in a number list.  The first item becomes the 
 * current element in the list.  
 * @param listID
 *   Enter the name of a valid number list whose first element you want to 
 *   retrieve.  
 * @param nvItem
 *   Contains the first element of the number list returned by this function.  
 */
function LONG ListGetFirstItem(LIST listID, BYREF NUMBER nvItem);
/**
 * Retrieves the first element in a string list.  The first string becomes 
 * the current element in the list.  
 * @param listID
 *   Enter the name of a valid string list whose first element you want to 
 *   retrieve.  
 * @param svString
 *   Contains the first element of the string list returned by this function.  
 */
function LONG ListGetFirstString(LIST listID, BYREF STRING svString);
/**
 * Retrieves the item after the current element in a number list.  The 
 * retrieved item becomes the current element in the list.  
 * @param listID
 *   Enter the name of a valid number list whose element you want to retrieve.  
 * @param nvItem
 *   Contains the item after the current element in the number list.  This item 
 *   becomes the current element in the list.  
 */
function LONG ListGetNextItem(LIST listID, BYREF NUMBER nvItem);
/**
 * Retrieves the element after the current element in a string list.  The 
 * retrieved element becomes the current element in the list.  
 * @param listID
 *   Enter the name of a valid string list whose element you want to retrieve.  
 * @param svString
 *   Contains the string after the current element of the string list.  This 
 *   string becomes the current element in the list.  
 */
function LONG ListGetNextString(LIST listID, BYREF STRING svString);
/**
 * Reads a text file into a list.  Once you load a text file into a list, you 
 * can use it for various functions in the setup, such as displaying a README 
 * file at the end of the setup, or writing a string list to the disk using 
 * the ListWriteToFile function.  This function gives you an easy way to load 
 * an entire file into a list, rather than building the list one item at a 
 * time.  
 * @param listID
 *   Enter the name of a valid empty string list created with the ListCreate 
 *   function.  This function reads the file and dumps each line of the file 
 *   into each element of the string list.  
 * @param szFile
 *   Enter the fully qualified name of the file you are creating the list from 
 *   in this parameter.  
 */
function LONG ListReadFromFile(LIST listID, STRING szFile);
/**
 * Updates the value of the current element in a number list to the value in 
 * nItem.  
 * @param listID
 *   Enter the name of a valid number list whose current element you want to 
 *   update.  
 * @param nItem
 *   Enter the numeric value you want to replace the current element with.  
 */
function LONG ListSetCurrentItem(LIST listID, NUMBER nItem);
/**
 * Updates the current element in the string list identified by listID to be 
 * equal to szString.  
 * @param listID
 *   Enter the name of a valid string list whose current element you want to 
 *   update.  
 * @param szString
 *   Enter the string you want to replace the current element with.  
 */
function LONG ListSetCurrentString(LIST listID, STRING szString);
/**
 * Makes a specific element in a string or number list the current element 
 * using an index.  You can also use constants to traverse a list an element 
 * at a time or to jump to the beginning or end of a list.  By using indexes 
 * to access items in a list, ListSetIndex allows you to treat numeric and 
 * string lists as arrays.  Index numbers start at zero (0).  
 * @param listID
 *   Enter the name of a valid list (either string or item) whose current 
 *   element you want to update.  
 * @param nIndex
 *   Enter the number of the location you want to set as the current location.  
 *   The numbering convention for this parameter begins with zero (0).  You can 
 *   also enter one of the constants listed.  
 *   <LI>LISTFIRST
 *   <LI>LISTLAST
 *   <LI>LISTNEXT
 *   <LI>LISTPREV
 */
function LONG ListSetIndex(LIST listID, NUMBER nIndex);
private enum rul_ListSetIndex_option {
   LISTFIRST
   LISTLAST
   LISTNEXT
   LISTPREV
}
/**
 * Writes a string list into a text file on the disk.  Without this function 
 * you must write the list one element at a time into the text file.  This 
 * function detects the newline characters at the end of each element and 
 * uses the characters as delimiters for each string in the list.  This 
 * function operates on string lists and text files only.  
 * @param listID
 *   Enter the name of a valid string list you would like to write into a file.  
 * @param szFileName
 *   Enter the fully qualified path and name of the file you are creating on 
 *   the disk to accept the list elements.  
 */
function LONG ListWriteToFile(LIST listID, STRING szFileName);
/**
 * Converts a short filename to its equivalent long filename.  
 * @param svPath
 *   Enter the short filename that you want to convert.  When you call the 
 *   function, the long filename is returned in this variable.  
 */
function LONG LongPathFromShortPath(BYREF STRING svPath);
/**
 * Places double quotation marks around long filenames.  Add double quotation 
 * marks to long filenames that contain spaces before passing the long 
 * filenames to the command line.  You must remove the double quotation marks 
 * from long filenames before converting them to short filenames using the 
 * LongPathToShortPath function.  
 * @param svPath
 *   Enter the long filename that you want to convert.  When you call the 
 *   function, the converted filename is returned in this variable.  
 * @param nParameter
 *   Determines whether the quotation marks are added to the long path or 
 *   removed from the long path.  
 *   <LI>TRUE
 *   <LI>FALSE
 */
function LONG LongPathToQuote(BYREF STRING svPath, BOOL nParameter);
/**
 * Converts a long filename to its equivalent short filename.  Short 
 * filenames are compatible with 16-bit programs such as NOTEPAD.EXE or 
 * MVIEWER2.EXE.  16-bit programs cannot accept long filenames.  
 * @param svPath
 *   Enter the long filename that you want to convert.  When you call the 
 *   function, the short filename is returned in this variable.  
 */
function LONG LongPathToShortPath(BYREF STRING svPath);
/**
 * Extracts the low-order word (two bytes) from the 32-bit integer value 
 * specified by lValue.  Advanced Microsoft Windows developers will recognize 
 * this as the LOWORD macro.  
 * @param lValue
 *   Enter the 32-bit integer from which you want to extract the lower two 
 *   bytes.  
 */
function LONG LOWORD(LONG lValue);
/**
 * Sounds a standard warning beep.  You can use a message beep anywhere in 
 * the script.  You may also find it useful to place message beeps at 
 * appropriate places in your script when you are testing your setup.  When 
 * you use a message beep this way, it can tell you if and when the script 
 * reaches a certain point.  
 * @param nReserved
 *   Enter 0 (zero) in this parameter.  No other value is allowed.  
 */
function LONG MessageBeep(NUMBER nReserved);
/**
 * Creates and displays a message box.  The message box contains a message 
 * and an icon.  You can change the contents of message box title bars with 
 * the SetDialogTitle function.  
 * @param szMsg
 *   Enter the message you want to display.  
 * @param nType
 *   Specify the type of message box to create and the type of icon you want to 
 *   appear in the message box.  
 *   <LI>INFORMATION
 *   <LI>SEVERE
 *   <LI>WARNING
 */
function LONG MessageBox(STRING szMsg, rul_MessageBox_type nType);
private enum rul_MessageBox_type {
   INFORMATION
   SEVERE
   WARNING
}
/**
 * Converts a number to a string.  
 * @param svString
 *   Returns the string equivalent of nValue.  
 * @param nValue
 *   Enter the number you want to convert into a string.  
 */
function LONG NumToStr(BYREF STRING svString, NUMBER nValue);
/**
 * Opens an existing text file or binary file.  Before you open the file, you 
 * must set the file mode using the OpenFileMode function.  Once you open a 
 * text file you can use GetLine to read from the file or WriteLine to write 
 * to the file.  Use ReadBytes and WriteBytes to read from and write to a 
 * binary file.  
 * @param nvFileHandle
 *   Returns the file handle of the file you are opening.  Use this handle to 
 *   identify the file when you use other file-related InstallShield functions.  
 * @param szPath
 *   Enter only the path of the file you want to open.  
 * @param szFileName
 *   Enter only the name of the file you want to open.  
 */
function LONG OpenFile(BYREF NUMBER nvFileHandle, STRING szPath, STRING szFileName);
/**
 * Sets the mode of the file you want to open or create.  The argument you 
 * pass as the nMode parameter sets the file mode to text file in read/write 
 * mode, text file in read-only mode, or binary file in read/write mode.  
 * @param nMode
 *   Specify which mode you want to use to open a file.  
 *   <LI>FILE_MODE_APPEND
 *   <LI>FILE_MODE_NORMAL
 *   <LI>FILE_MODE_BINARY
 *   <LI>FILE_MODE_BINARYREADONLY
 */
function LONG OpenFileMode(rul_file_mode_flags nMode);
private enum rul_file_mode_flags {
   FILE_MODE_APPEND
   FILE_MODE_NORMAL
   FILE_MODE_BINARY
   FILE_MODE_BINARYREADONLY
}
/**
 * Separates a full path string into its component parts without using the 
 * string manipulation functions.  \n\n** Not available in Visual C++ Edition 
 * ** 
 * @param svReturnString
 *   Contains the return value returned by this function based on the operation 
 *   you specify.  
 * @param szPath
 *   Enter the path you want to parse (separate).  
 * @param nOperation
 *   Specify what you want to parse from the path.  
 *   <LI>DIRECTORY
 *   <LI>DISK
 *   <LI>EXTENSION_ONLY
 *   <LI>FILENAME
 *   <LI>FILENAME_ONLY
 *   <LI>PATH
 */
function LONG ParsePath(BYREF STRING svReturnString, STRING szPath, rul_ParsePath_option nOperation);
private enum rul_ParsePath_option {
   DIRECTORY
   DISK
   EXTENSION_ONLY
   FILENAME
   FILENAME_ONLY
   PATH
}
/**
 * Adds a search folder to the Path Buffer.  Specify the position of the 
 * folder in relation to an existing folder in the Path Buffer.  The folder 
 * can be added as the first or the last folder of the Path Buffer.  
 * @param szDir
 *   Enter the folder you want to add to the Path Buffer.  You can enter either 
 *   the full path and folder, or the folder name only.  
 * @param szRefDir
 *   Enter the folder name you are using as a reference to locate szDir in the 
 *   path.  You can enter either the fully qualified path or just the folder 
 *   name.  
 * @param bRefDir
 *   Specifies if szRefDir includes a fully qualified path or the folder name 
 *   only.  FULL indicates that szRefDir contains a fully qualified path.  
 *   PARTIAL indicates that szRefDir contains the folder name only.  
 *   <LI>FULL
 *   <LI>PARTIAL
 * @param bPosition
 *   Enter where you want szDir added to the path temporary buffer.  BEFORE 
 *   specifies that you want to add szDir before szRefDir.  AFTER specifies 
 *   that you want to add szDir after szRefDir.  
 *   <LI>BEFORE
 *   <LI>AFTER
 */
function LONG PathAdd(STRING szDir, STRING szRefDir, rul_full_partial bRefDir, rul_before_after bPosition);
private enum rul_full_partial {
   FULL
   PARTIAL
}
/**
 * Deletes a specific folder in the Path Buffer.  You can specify the name of 
 * the folder or enter a fully qualified path.  This function has no 
 * relationship to the path statement in the Autoexec.bat file or the path 
 * environment variable.  It acts only on the Path Buffer, which helps you 
 * build, modify, and manipulate search paths.  Use the PathGet and PathSet 
 * functions to get and set the contents of the Path Buffer.  
 * @param szDir
 *   Enter the folder you want to remove from the Path Buffer.  You can enter 
 *   either the full path and folder name, or the folder name only.  
 * @param bDir
 *   Specify if the folder in szDir is a fully qualified path and folder or a 
 *   folder name only.  
 *   <LI>FULL
 *   <LI>PARTIAL
 */
function LONG PathDelete(STRING szDir, rul_full_partial bDir);
/**
 * Searches the Path Buffer for a specific folder.  You can specify the 
 * folder with either a fully qualified path or the folder name only.  This 
 * function has no relationship to the path statement in the Autoexec.bat 
 * file or the path environment variable.  It acts only on the Path Buffer, 
 * which helps you build, modify, and manipulate search paths.  You can then 
 * add this temporary path string to the Autoexec.bat file using the various 
 * Batch file functions.  
 * @param szDir
 *   Enter the name of the folder you are searching for in the Path Buffer.  
 *   You can enter either the fully qualified folder and path, or the folder 
 *   name only.  
 * @param svResult
 *   Contains the full folder and path found in the Path Buffer returned by the 
 *   function.  
 * @param bDir
 *   Specify whether the folder in szDir is a fully qualified path and folder 
 *   or a folder name only.  
 *   <LI>FULL
 *   <LI>PARTIAL
 * @param bSearch
 *   Specify if you want the function to continue the search from where it left 
 *   off after the previous search, or to start the search from the beginning 
 *   of the Path Buffer.  
 *   <LI>CONTINUE
 *   <LI>RESTART
 */
function LONG PathFind(STRING szDir, BYREF STRING svResult, rul_full_partial bDir, rul_continue_restart bSearch);
/**
 * Retrieves the path string currently stored in the temporary path string 
 * buffer.  You can use Path functions to manipulate the Path Buffer.  The 
 * PathGet function is used to retrieve the path string.  This function has 
 * no relationship to the path statement in the Autoexec.bat file or the path 
 * environment variable.  It acts on the Path Buffer only, which helps you 
 * build, modify, and manipulate search paths.  You can then add this 
 * temporary path string to the Autoexec.bat file using the various Batch 
 * file functions.  
 * @param svString
 *   Contains the contents of the temporary path string buffer returned by the 
 *   function.  
 */
function LONG PathGet(BYREF STRING svString);
/**
 * Repositions a folder in the Path Buffer to another location.  You can also 
 * use this function to position the folder relative to another folder or, as 
 * the first or the last item in the path string.  Use the PathGet and 
 * PathSet functions to get and set contents of the Path Buffer.  This 
 * function has no relation to the PATH statement in the Autoexec.bat file or 
 * the PATH environment variable.  It acts only on the Path Buffer, which 
 * helps you build, modify, and manipulate search paths.  
 * @param szDir
 *   Enter the name of the folder you want to reposition in the Path Buffer.  
 *   You can enter either the full path and folder name, or the folder name 
 *   only.  
 * @param szRefDir
 *   Enter the folder relative to where szDir will be repositioned.  If you 
 *   enter a null string in this parameter, szDir becomes the first or the last 
 *   item.  
 * @param bDir
 *   Specify whether the folder in szDir is a fully qualified path and folder 
 *   or a folder name only.  
 *   <LI>FULL
 *   <LI>PARTIAL
 * @param bRefDir
 *   Specify whether szRefDir contains a fully qualified path and folder or 
 *   just a folder name.  
 *   <LI>FULL
 *   <LI>PARTIAL
 * @param bPosition
 *   Specify where you want the function to move szDir in the path temporary 
 *   buffer.  
 *   <LI>AFTER
 *   <LI>BEFORE
 */
function LONG PathMove(STRING szDir, STRING szRefDir, rul_full_partial bDir, rul_full_partial bRefDir, rul_before_after bPosition);
/**
 * Stores a search path string in the Path Buffer.  You can then manipulate 
 * this buffer using the other path functions.  This function has no relation 
 * to the PATH statement in the Autoexec.bat file or the PATH environment 
 * variable.  It acts only on the Path Buffer, which helps you build, modify, 
 * and manipulate search paths.  You can then add this temporary path string 
 * to the Autoexec.bat file or PATH environment variable.  
 * @param szString
 *   The path to store in a temporary Path Buffer.  You can then use other Path 
 *   functions to modify/manipulate it.  szString must contain a drive letter, 
 *   a colon, and a root folder (a backslash).  
 */
function LONG PathSet(STRING szString);
/**
 * Places a bitmap anywhere on the user's screen.  Bitmaps can either be 
 * included in a DLL or they can be read in from a .bmp or .wmf file.  The 
 * bitmap is placed in the specified corner of the screen.  You specify the 
 * distance between the sides of the bitmap and the edges of the screen in 
 * the nDx and nDy parameters.  You can also center bitmaps automatically in 
 * the main window.  If you are going to place multiple bitmaps in the same 
 * location during the setup, remove the current bitmap before placing the 
 * next bitmap.  
 * @param szName
 *   Enter the fully qualified path and filename of the DLL containing the 
 *   bitmaps, or of the .bmp or .wmf file.  If you do not include an extension, 
 *   InstallShield assumes the value you enter is a DLL filename.  
 * @param nID_BITMAP
 *   Enter a unique ID that identifies the bitmap.  If the bitmap is from a 
 *   DLL, this ID must be the resource ID of the bitmap in the DLL.  
 * @param nDx
 *   Enter the horizontal distance in pixels between the appropriate edge of 
 *   the bitmap and the edge of the screen.  You can enter CENTERED in this 
 *   parameter to center the bitmap horizontally in the Main window.  
 * @param nDy
 *   Enter the vertical pixel distance between the appropriate edge of the 
 *   bitmap and the edge of the screen.  You can enter CENTERED in this 
 *   parameter to center the bitmap vertically in the Main window.  
 * @param nDrawOp
 *   Specify the corner of the screen relative to where you want your bitmap 
 *   placed.  Use the REMOVE constant to remove a previously placed bitmap.  
 *   <LI>BITMAPICON
 *   <LI>CENTERED
 *   <LI>FULLSCREEN
 *   <LI>FULLSCREENSIZE
 *   <LI>LOWER_LEFT
 *   <LI>LOWER_RIGHT
 *   <LI>TILED
 *   <LI>UPPER_LEFT
 *   <LI>UPPER_RIGHT
 *   <LI>REMOVE
 */
function LONG PlaceBitmap(STRING szName, NUMBER nID_BITMAP, NUMBER nDx, NUMBER nDy, rul_PlaceBitmap_option nDrawOp);
private enum rul_PlaceBitmap_option {
   BITMAPFADE
   BITMAPICON
   CENTERED
   FULLSCREEN
   FULLSCREENSIZE
   LOWER_LEFT
   LOWER_RIGHT
   TILED
   UPPER_LEFT
   UPPER_RIGHT
   REMOVE
}
/**
 * Changes the position of user interface objects, including billboards and 
 * AVI playback windows.  You specify the distance between the sides of the 
 * object and the edges of the screen in the nDx and nDy parameters.  
 * @param nObject
 *   Specify the object whose position you want to change.  
 *   <LI>ASKOPTIONS
 *   <LI>ASKPATH
 *   <LI>ASKTEXT
 *   <LI>BACKGROUND
 *   <LI>BILLBOARD
 *   <LI>ENTERDISK
 *   <LI>FEEDBACK
 *   <LI>MMEDIA_AVI
 *   <LI>STATUS
 *   <LI>STATUSDLG
 * @param nDx
 *   Enter the distance in pixels between the edge of the object and the edge 
 *   of the screen on the horizontal axis.  When passing FEEDBACK as the 
 *   nObject parameter, CENTERED centers the information gauge horizontally.  
 * @param nDy
 *   Enter the distance in pixels between the edge of the object and the edge 
 *   of the screen on the vertical axis.  When passing FEEDBACK as the nObject 
 *   parameter, CENTERED centers the information gauge vertically.  
 * @param nCorner
 *   Specify from which corner to measure the distances, expressed in nDx and 
 *   nDy.  
 *   <LI>LOWER_LEFT
 *   <LI>LOWER_RIGHT
 *   <LI>UPPER_LEFT
 *   <LI>UPPER_RIGHT
 *   <LI>CENTERED
 */
function LONG PlaceWindow(rul_PlaceWindow_option nObject, NUMBER nDx, NUMBER nDy, rul_PlaceWindow_position nCorner);
private enum rul_PlaceWindow_option {
   ASKDESTPATH
   ASKOPTIONS
   ASKPATH
   ASKTEXT
   BACKGROUND
   BILLBOARD
   ENTERDISK
   FEEDBACK
   MMEDIA_AVI
   STATUS
   STATUSDLG
}
private enum rul_PlaceWindow_position {
   LOWER_LEFT
   LOWER_RIGHT
   UPPER_LEFT
   UPPER_RIGHT
   CENTERED
}
/**
 * Plays a sound (WAVE or MIDI) or video (AVI) file.  \n\n** Not available in 
 * Visual C++ Edition ** 
 * @param nType
 *   Enter the type of file you want to play.  
 *   <LI>MMEDIA_AVI
 *   <LI>MMEDIA_MIDI
 *   <LI>MMEDIA_WAVE
 * @param szFileName
 *   Enter the fully qualified path and filename of the sound or AVI file to be 
 *   played.  
 * @param nOperation
 *   Enter the playing mode.  You can join MMEDIA_PLAYASYNCH and 
 *   MMEDIA_PLAYCONTINUOUS with the bitwise OR operator ( | ) to play a WAVE or 
 *   AVI file continuously.  
 *   <LI>MMEDIA_PLAYSYNCH
 *   <LI>MMEDIA_PLAYASYNCH
 *   <LI>MMEDIA_PLAYCONTINUOUS
 *   <LI>MMEDIA_STOP
 * @param nReserved
 *   Enter 0 (zero) in this parameter.  No other value is allowed.  
 */
function LONG PlayMMedia(rul_PlayMMedia_type nType, STRING szFileName, rul_PlayMMedia_option nOperation, NUMBER nReserved);
private enum rul_PlayMMedia_type {
   MMEDIA_AVI
   MMEDIA_MIDI
   MMEDIA_WAVE
}
private enum rul_PlayMMedia_option {
   MMEDIA_PLAYSYNCH
   MMEDIA_PLAYASYNCH
   MMEDIA_PLAYCONTINUOUS
   MMEDIA_STOP
}
/**
 * Designates a program group as either Personal or Common under Windows NT.  
 * Call the ProgDefGroupType function before you call AddFolderIcon or 
 * CreateProgramFolder.  The default program group type is Common.  This 
 * function is only for use in a Windows NT environment.  
 * @param nType
 *   Enter a constant to specify a program group type.  
 *   <LI>PERSONAL
 *   <LI>COMMON
 */
function LONG ProgDefGroupType(rul_personal_common nType);
private enum rul_personal_common {
   PERSONAL
   COMMON
}
/**
 * Checks for the existence of a specific program group.  On Windows NT 
 * systems, QueryProgGroup also determines whether a program group is of 
 * Common or Personal type.  If InstallShield finds the program group, 
 * QueryProgGroup returns the program group's attributes.  The attributes 
 * include the path of the group and the number of items in the group, and 
 * the group type (Windows NT only).  Since there are no program groups in 
 * Windows 95, this function does not apply to it.  
 * @param szGroupName
 *   Enter the name of the program group you are looking for.  
 * @param svGroupPath
 *   Contains the fully qualified path of the group specified in szGroupName.  
 *   Note Under Windows NT, svGroupPath is ignored because it is stored in the 
 *   registry.  
 * @param nvItemCount
 *   Under Windows 3.1, nvItemCount contains the number of program items in the 
 *   group.  
 */
function LONG QueryProgGroup(STRING szGroupName, BYREF STRING svGroupPath, BYREF NUMBER nvItemCount);
/**
 * Checks for the existence of a specific program item or subfolder name.  If 
 * InstallShield finds the item or subfolder, QueryProgItem returns its 
 * attributes.  The attributes include the application's command line, 
 * working folder, icon path, shortcut key, and minimize flag.  QueryProgItem 
 * only checks for the existence of subfolder names successfully under 
 * Windows NT version 4.0 and Windows 95.  
 * @param szFolderName
 *   Enter the name of the folder containing the item or subfolder.  
 *   <LI>szFolderName
 *   <LI>FOLDER_DESKTOP
 *   <LI>FOLDER_STARTMENU
 *   <LI>FOLDER_STARTUP
 * @param szItemName
 *   Enter the name of the program item or subfolder you are looking for.  
 * @param svCmdLine
 *   Contains either the command line of the item's executable file or the 
 *   complete path of the subfolder (under Windows 95 and Windows NT 4.0).  
 * @param svWrkDir
 *   Contains the full path of the working folder of the program item.  (Not 
 *   applicable if szItemName is a subfolder.) 
 * @param svIconPath
 *   Contains the full path and filename of the ICO file or .exe file.  (Not 
 *   applicable if szItemName is a subfolder.) 
 * @param nvIconIndex
 *   Contains the index of the icon used for the program item.  (Not applicable 
 *   if szItemName is a subfolder.) 
 * @param svShortCutKey
 *   Contains the item's shortcut key.  (Not applicable if szItemName is a 
 *   subfolder.) 
 * @param nvMinimizeFlag
 *   (Not applicable if szItemName is a subfolder.) Contains a numeric value 
 *   indicating whether an application window is minimized when first 
 *   displayed.  
 */
function LONG QueryProgItem(rul_folder_name szFolderName, STRING szItemName, BYREF STRING svCmdLine, BYREF STRING svWrkDir, BYREF STRING svIconPath, BYREF NUMBER nvIconIndex, BYREF STRING svShortCutKey, BYREF NUMBER nvMinimizeFlag);
/**
 * Retrieves the name of the program shell.  For example, if the program 
 * shell is Program Manager, InstallShield returns the string "PROGMAN.EXE" 
 * with this function.  
 * @param svShellMgrName
 *   Returns the name of the shell manager that is currently running.  Only the 
 *   program name is returned, even though a path may be specified in the 
 *   Win.ini file.  
 */
function LONG QueryShellMgr(BYREF STRING svShellMgrName);
/**
 * Reads a specific number of bytes from a file starting at the current file 
 * pointer location.  You must open the file in binary mode using the 
 * OpenFileMode and OpenFile functions before you can read from the file.  
 * The nIndex parameter is an index into the svString parameter.  \n\n** Not 
 * available in Visual C++ Edition ** 
 * @param nFileHandle
 *   Enter the file handle to a file opened in binary mode.  
 * @param svString
 *   Contains the bytes read from the file and returned by this function.  This 
 *   variable must be long enough to accommodate the requested number of bytes.  
 * @param nIndex
 *   Enter the index into svString where the bytes are written.  In most cases 
 *   you enter zero in this parameter, so the bytes are copied to the first 
 *   location of svString.  
 * @param nBytes
 *   Enter the number of bytes you want to read from the file.  Bytes are read 
 *   starting from the current location of the file pointer.  InstallShield 
 *   relocates the file pointer as the bytes are read.  
 */
function LONG ReadBytes(NUMBER nFileHandle, BYREF STRING svString, NUMBER nIndex, NUMBER nBytes);
/**
 * Displays a dialog box that allows the user to reboot the machine or 
 * restart Windows.  If the user selects either of these options, 
 * InstallShield exits the setup script and attempts to carry out the 
 * selected operation.  If the user chooses not to reboot the machine or 
 * restart Windows, execution returns to the setup script.  If the reboot 
 * operation fails, the RebootDialog continues to display.  
 * @param szTitle
 *   Enter the text you want to display in the title of the dialog box.  
 * @param szMsg
 *   Enter the message you want to display.  
 * @param nDefChoice
 *   Specify the default radio button selection.  
 *   <LI>SYS_BOOTWIN
 *   <LI>SYS_BOOTMACHINE
 *   <LI>0
 */
function LONG RebootDialog(STRING szTitle, STRING szMsg, rul_RebootDialog_option nDefChoice);
private enum rul_RebootDialog_option {
   SYS_BOOTWIN
   SYS_BOOTMACHINE
   0
}
/**
 * Creates a connection to a remote registry.  \n\n** Not available in Visual 
 * C++ Edition ** 
 * @param szRemoteSystem
 *   Enter the name of the system you want to connect to, such as "RemoteSys".  
 * @param nKeyType
 *   Specify which key you wish to access.  
 *   <LI>HKEY_LOCAL_MACHINE
 *   <LI>HKEY_USERS
 * @param nReserved
 *   Enter 0 (zero) in this parameter.  No other value is allowed.  
 */
function LONG RegDBConnectRegistry(STRING szRemoteSystem, rul_hkey_type nKeyType, NUMBER nReserved);
private enum rul_hkey_type {
   HKEY_LOCAL_MACHINE
   HKEY_USERS
}
/**
 * Creates a key in the registry.  You can also associate a class object with 
 * the newly created key (advanced users only).  The newly created key does 
 * not have a value associated with it.  Unless you specify otherwise, 
 * InstallShield creates the key as a subkey of HKEY_CLASSES_ROOT.  
 * @param szKey
 *   Enter the name of the key you want to create under one of the four root 
 *   keys.  
 * @param szClass
 *   Enter the class name you are associating with this key.  
 */
function LONG RegDBCreateKeyEx(STRING szKey, STRING szClass);
/**
 * Deletes a specific key and its associated value from the registry.  All 
 * subkeys of the deleted key are also deleted, along with their associated 
 * values.  InstallShield assumes the key specified in szSubKey is a subkey 
 * of HKEY_CLASSES_ROOT.  You can use RegDBSetDefaultRoot to specify another 
 * root key.  
 * @param szSubKey
 *   Enter the name of the key you want to delete.  
 */
function LONG RegDBDeleteKey(STRING szSubKey);
/**
 * Deletes a value from a specifice key in the registry.  InstallShield 
 * assumes that the key specified in szSubKey is a subkey of 
 * HKEY_CLASSES_ROOT.  You must use RegDBSetDefaultRoot to specify another 
 * root key.  
 * @param szSubKey
 *   Enter the name of the registry key that contains the value name you want 
 *   to delete.  
 * @param szValue
 *   Enter the name of the value you want to delete.  
 */
function LONG RegDBDeleteValue(STRING szSubKey, STRING szValue);
/**
 * Closes a connection to a remote registry that you established by calling 
 * RegDBConnectRegistry.  \n\n** Not available in Visual C++ Edition ** 
 * @param nReserved
 *   Enter 0 (zero) in this parameter.  No other value is allowed.  
 */
function LONG RegDBDisConnectRegistry(NUMBER nReserved);
/**
 * Retrieves the value of a particular value name under the application 
 * information key of your main application in the registry.  The application 
 * information key is created by InstallShield as a result of calling the 
 * InstallationInfo function.  You must call InstallationInfo to create an 
 * application information key before calling RegDBGetAppInfo.  
 * @param szName
 *   Enter the value name whose value you want to retrieve.  
 * @param nvType
 *   Returns the type of data, identified by one of these constants: 
 *   REGDB_STRING, REGDB_STRING_EXPAND, REGDB_STRING_MULTI, REGDB_NUMBER, or 
 *   REGDB_BINARY.  
 * @param svValue
 *   Returns the value of the value name specified in szName.  
 * @param nvSize
 *   Returns the size, in bytes, of the return value.  
 */
function LONG RegDBGetAppInfo(STRING szName, BYREF NUMBER nvType, BYREF STRING svValue, BYREF NUMBER nvSize);
/**
 * Retrieves values under the per-application paths key or the application 
 * uninstallation key, depending on the value of nItem.  
 * @param nItem
 *   Enter the predefined item you want to retrieve.  
 *   <LI>REGDB_APPPATH
 *   <LI>REGDB_APPPATH_DEFAULT
 *   <LI>REGDB_UNINSTALL_NAME
 * @param svValue
 *   Returns the value of the item.  
 */
function LONG RegDBGetItem(rul_regdb_item nItem, BYREF STRING svValue);
private enum rul_regdb_item {
   REGDB_APPPATH
   REGDB_APPPATH_DEFAULT
   REGDB_UNINSTALL_NAME
}
/**
 * Retrieves the value of a particular value name under a specified key in 
 * the registry.  By default, InstallShield assumes this key is a subkey of 
 * HKEY_CLASSES_ROOT.  You can use RegDBSetDefaultRoot to specify another 
 * root key.  
 * @param szKey
 *   Enter the key name whose value you want to retrieve.  
 * @param szName
 *   Enter the value name under szKey for which you want to retrieve the value.  
 *   When you pass a null string (""), RegDBGetKeyValueEx retrieves the default 
 *   value for the key.  
 * @param nvType
 *   Returns the type of data, identified by one of these constants: 
 *   REGDB_STRING, REGDB_STRING_EXPAND, REGDB_STRING_MULTI, REGDB_NUMBER, or 
 *   REGDB_BINARY.  
 * @param svValue
 *   Points to the string containing the data.  Numbers are converted in the 
 *   string.  
 * @param nvSize
 *   Returns size, in bytes, of the data you are retrieving.  
 */
function LONG RegDBGetKeyValueEx(STRING szKey, STRING szName, BYREF NUMBER nvType, BYREF STRING svValue, BYREF NUMBER nvSize);
/**
 * Determines if a specific key exists in the registry.  By default, 
 * InstallShield assumes this key is a subkey of HKEY_CLASSES_ROOT.  If you 
 * want to use a different main key, use RegDBSetDefaultRoot to specify 
 * another root key.  
 * @param szSubKey
 *   Enter the name of the key whose existence you want to check.  
 */
function LONG RegDBKeyExist(STRING szSubKey);
/**
 * Queries a key for its subkeys and value names.  The keys can be enumerated 
 * dynamically at run time using this function.  
 * @param szSubKey
 *   Specify a subkey.  This can be a null string (""), in which case the data 
 *   retrieved is the root key.  
 * @param nItem
 *   This indicates which items should be placed in the list.  
 *   <LI>REGDB_KEYS
 *   <LI>REGDB_NAMES
 * @param listResults
 *   String list which will contain the results of the query.  
 */
function LONG RegDBQueryKey(STRING szSubKey, rul_RegDBQueryKey_option nItem, LIST listResults);
private enum rul_RegDBQueryKey_option {
   REGDB_KEYS
   REGDB_NAMES
}
/**
 * Sets the value of a particular value name under the application 
 * information key in the registry.  You must call InstallationInfo to create 
 * an application information key before calling RegDBSetAppInfo.  
 * @param szName
 *   Enter the value name whose information you want to set.  
 * @param nType
 *   Enter the type of data you are setting.  
 * @param szValue
 *   Enter the value you are setting for the value name.  
 * @param nSize
 *   Enter the size, in bytes, of the data you are passing.  If you enter -1 in 
 *   this parameter InstallShield automatically determines the size of the 
 *   data.  
 */
function LONG RegDBSetAppInfo(STRING szName, NUMBER nType, STRING szValue, NUMBER nSize);
/**
 * Sets a different root key to be used by other registry functions.  Most 
 * InstallShield registry functions work on the HKEY_CLASSES_ROOT as the 
 * default base of the registry tree.  Using this function, you can specify 
 * another key, such as HKEY_LOCAL_MACHINE or HKEY_CURRENT_USER or 
 * HKEY_USERS, as the root key.  
 * @param nRootKey
 *   Specify the key you want to set as the root key.  
 *   <LI>HKEY_CLASSES_ROOT
 *   <LI>HKEY_CURRENT_USER
 *   <LI>HKEY_LOCAL_MACHINE
 *   <LI>HKEY_USERS
 *   <LI>HKEY_CURRENT_CONFIG
 *   <LI>HKEY_DYN_DATA
 */
function LONG RegDBSetDefaultRoot(rul_root_key nRootKey);
private enum rul_root_key {
   HKEY_CLASSES_ROOT
   HKEY_CURRENT_USER
   HKEY_LOCAL_MACHINE
   HKEY_USERS
   HKEY_CURRENT_CONFIG
   HKEY_DYN_DATA
   HKEY_PERFORMANCE_DATA
}
/**
 * Assigns values under the per application paths key or the application 
 * uninstallation key, depending on the value of nItem.  Calling RegDBSetItem 
 * with either the REGDB_APPPATH or the REGDB_APPPATH_DEFAULT option results 
 * in the creation of the per application paths key (InstallationInfo only 
 * provides information used to create it).  
 * @param nItem
 *   Enter the item you want to set.  
 *   <LI>REGDB_APPPATH
 *   <LI>REGDB_APPPATH_DEFAULT
 *   <LI>REGDB_UNINSTALL_NAME
 * @param szValue
 *   Enter the value you are setting to the specified item.  
 */
function LONG RegDBSetItem(rul_regdb_item nItem, STRING szValue);
/**
 * Sets the value of a specified value name under a key in the registry.  If 
 * the key does not already exist, RegDBSetKeyValueEx will create it for you.  
 * However, the newly created key will not be logged for uninstallation 
 * unless it is a subkey of a key already logged for uninstallation.  
 * InstallShield assumes the value name in szKey is a subkey of the 
 * HKEY_CLASSES_ROOT key.  If you want to use a different main key, use the 
 * RegDBSetDefaultRoot function to set the main root key.  
 * @param szKey
 *   Enter the name of the key you want to set after you have created it with 
 *   RegDBCreateKeyEx.  
 * @param szName
 *   Enter the value name for the value data you want to set.  
 * @param nType
 *   Enter the type of data you are setting.  
 *   <LI>REGDB_STRING
 *   <LI>REGDB_STRING_EXPAND
 *   <LI>REGDB_STRING_MULTI
 *   <LI>REGDB_NUMBER
 *   <LI>REGDB_BINARY
 * @param szValue
 *   Enter the value you are associating with the value as a string variable.  
 *   Numbers must be expressed as strings.  
 * @param nSize
 *   Data size in bytes.  Enter -1 when nType is REGDB_STRING, 
 *   REGDB_STRING_EXPAND, or REGDB_NUMBER, and InstallShield sets the size.  
 *   With REGDB_BINARY and REGDB_STRING_MULTI, you specify the size.  
 */
function LONG RegDBSetKeyValueEx(STRING szKey, STRING szName, rul_registry_value_type nType, STRING szValue, NUMBER nSize);
private enum rul_registry_value_type {
   REGDB_STRING
   REGDB_STRING_EXPAND
   REGDB_STRING_MULTI
   REGDB_NUMBER
   REGDB_BINARY
}
/**
 * Frees all memory associated with the custom dialog identified in 
 * szDialogName.  Call this function after calling the EndDialog function.  
 * Call this function outside the message handling case statement.  \n\n** 
 * Not available in Visual C++ Edition ** 
 * @param szDialogName
 *   Enter the name of the dialog you want to destroy.  
 */
function LONG ReleaseDialog(STRING szDialogName);
/**
 * Instructs the shell to remove and reload a specific folder.  If you make 
 * modifications to program folder files directly and wish to immediately 
 * view the changes, call this function to force the shell to update the 
 * folder.  This function is for advanced users who want to directly modify 
 * folder files.  
 * @param szGroupName
 *   Enter the name of the program folder you want to reload.  
 */
function LONG ReloadProgGroup(STRING szGroupName);
/**
 * Changes the name of a file.  Enter only the filename in each parameter, 
 * not the path.  RenameFile uses the SRCDIR system variable as the path for 
 * the szFileOld parameter, and the TARGETDIR system variable as the path for 
 * the szFileNew parameter.  You can also use RenameFile to move a file.  To 
 * move a file, make SRCDIR equal to the current folder of the file, and 
 * TARGETDIR equal to the new folder.  You can only rename one file with each 
 * RenameFile statement.  You cannot use wild card characters in this 
 * function.  
 * @param szFileOld
 *   Enter only the name of the file you want to rename.  Do not enter the 
 *   path.  RenameFile uses the path in the SRCDIR system variable.  
 * @param szFileNew
 *   Enter only the new name of the file.  Do not enter the path.  RenameFile 
 *   uses the path in the TARGETDIR system variable.  
 */
function LONG RenameFile(STRING szFileOld, STRING szFileNew);
/**
 * Replaces an icon in a specified folder.  You must specify an existing 
 * folder, either one you have created with the CreateProgramFolder function 
 * or one that already exists on the user's system.  
 * @param szProgramFolder
 *   Enter the name of the folder that contains the icon you want to replace.  
 * @param szItemName
 *   Enter the name of the icon you are replacing.  
 * @param szNewItem
 *   Enter the name of the icon as it should appear after the replacement.  
 * @param szCmdLine
 *   Enter the full path and filename of the icon you are replacing.  
 * @param szWorkingDir
 *   Enter the full path and filename of the icon you want to use to replace 
 *   the current icon.  
 * @param szIconPath
 *   Enter the name of an alternate icon file or a valid Windows executable 
 *   that contains the new icon.  
 * @param nIcon
 *   Enter the icon ordinal if you specified a Window executable icon.  
 *   Otherwise, enter zero in this parameter.  
 * @param szShortCutKey
 *   Enter the string that contains the shortcut key sequence the user can 
 *   press to start the program.  For example, "Ctrl + Alt + 1".  
 * @param nFlag
 *   Specify how you want the icon to appear.  
 *   <LI>NULL
 *   <LI>REPLACE
 *   <LI>RUN_MAXIMIZED
 *   <LI>RUN_MINIMIZED
 *   <LI>RUN_SEPARATEMEMORY
 */
function LONG ReplaceFolderIcon(STRING szProgramFolder, STRING szItemName, STRING szNewItem, STRING szCmdLine, STRING szWorkingDir, STRING szIconPath, NUMBER nIcon, STRING szShortCutKey, rul_folder_flag nFlag);
/**
 * Replaces a profile string in an INI file.  This function can replace 
 * values of duplicate keys.  If you are adding unique keys (i.e., keys that 
 * are all different for a given section), use the WriteProfString function.  
 * Use this function to replace only non-unique key names such as the device= 
 * line in the System.ini file.  \n\n** Not available in Visual C++ Edition 
 * ** 
 * @param szFileName
 *   Enter the name of the INI file.  If you do not include a fully qualified 
 *   path and filename, ReplaceProfString searches the Windows folder.  If the 
 *   file does not exist, this function creates the file in the Windows folder.  
 * @param szSectionName
 *   Enter the section where you want to search for szKeyName.  Do not include 
 *   section name delimiting brackets ( [] ).  If the section does not exist, 
 *   InstallShield creates it for you.  
 * @param szKeyName
 *   Enter the name of the key you want to place in the INI file.  If the key 
 *   does not exist, InstallShield creates it for you.  
 * @param szOrigValue
 *   Enter the value of the key=value line you want to search for and replace.  
 * @param szReplaceValue
 *   Enter the new value you want to associate with szKeyName.  
 */
function LONG ReplaceProfString(STRING szFileName, STRING szSectionName, STRING szKeyName, STRING szOrigValue, STRING szReplaceValue);
/**
 * Creates a custom color value that can be used with SetColor and SetTitle.  
 * @param constRed
 *   Enter a numeric constant from 0 to 255 to indicate the amount of red in 
 *   the custom color.  
 * @param constGreen
 *   Enter a numeric constant from 0 to 255 to indicate the amount of green in 
 *   the custom color.  
 * @param constBlue
 *   Enter a numeric constant from 0 to 255 to indicate the amount of blue in 
 *   the custom color.  
 */
function LONG RGB(INT constRed, INT constGreen, INT constBlue);
/**
 * Creates a dialog box that allows you to select an alternate destination 
 * folder.  If you enter a folder that does not exist, the function requests 
 * confirmation.  
 * @param szTitle
 *   Enter the text you want to display in the title of the dialog box.  
 * @param szMsg
 *   Enter the text you want to display in the dialog box.  The text is 
 *   considered a static control.  
 * @param svDir
 *   Enter the name of the folder you want to appear as the default folder.  
 *   This variable contains the chosen folder after the function executes.  
 * @param nReserved
 *   Enter 0 (zero) in this parameter.  No other value is allowed.  
 */
function LONG SdAskDestPath(STRING szTitle, STRING szMsg, BYREF STRING svDir, NUMBER nReserved);
/**
 * Offers selection from up to four options, which are typically components 
 * or subcomponents.  Also allows use of a modified copy of the SdAskOptions 
 * dialog.  \n\n** Not available in Visual C++ Edition ** 
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  
 * @param szMsg1
 *   Enter a message you want to appear in the dialog box.  If using a modified 
 *   copy of the SdAskOptions dialog, note that this static field has an ID of 
 *   801.  
 * @param szMsg2
 *   Enter a second message you want to appear in the dialog box.  If using a 
 *   modified copy of the SdAskOptions dialog, note that this static field has 
 *   an ID of 802.  
 * @param szId
 *   Enter a null string ("") to use the standard SdAskOptions dialog box.  Or, 
 *   enter the ID of a modifed copy of the SdAskOptions dialog.  Use a numeric 
 *   ID in string form (e.g., 13001 as "13001").  
 * @param szComponent
 *   Enter a null string ("") to show top-level components.  Or, enter the name 
 *   of a component whose subcomponents you want to display for selection.  
 * @param nExclusiveFlag
 *   Specify whether you want the options to use radio buttons (EXCLUSIVE) or 
 *   check boxes (NONEXCLUSIVE).  
 */
function LONG SdAskOptions(STRING szTitle, STRING szMsg1, STRING szMsg2, STRING szId, STRING szComponent, rul_exclusive nExclusiveFlag);
/**
 * Offers list box selection of options, which are typically components or 
 * subcomponents.  \n\n** Not available in Visual C++ Edition ** 
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  
 * @param szMsg
 *   Enter the text you want to appear in the dialog box.  
 * @param szComponent
 *   Enter a null string ("") to show top-level components.  Or, enter the name 
 *   of a component whose subcomponents you want to display for selection.  
 * @param nStyle
 *   Specify whether users can select only one (EXCLUSIVE) or multiple 
 *   (NONEXCLUSIVE) options.  
 */
function LONG SdAskOptionsList(STRING szTitle, STRING szMsg, STRING szComponent, rul_exclusive nStyle);
/**
 * Displays a bitmap in a dialog box.  The maximum allowable size of the 
 * bitmap is 440 pixels wide by 275 pixels high.  You can also display a 
 * message in the SdBitmap dialog box, but only if you use a resource editor 
 * to modify the SdBitmap dialog box resource so that the control that 
 * displays the message is made visible.  \n\n** Not available in Visual C++ 
 * Edition ** 
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  
 * @param szMsg
 *   Enter a null string ("") in the szMsg parameter, unless you use a resource 
 *   editor to modify the SdBitmap dialog box to display a message.  
 * @param szBitmap
 *   Enter the name of the bitmap you want to display.  InstallShield searches 
 *   in SUPPORTDIR for the bitmap, unless you specify a full qualified path and 
 *   filename for the bitmap.  
 */
function LONG SdBitmap(STRING szTitle, STRING szMsg, STRING szBitmap);
/**
 * Displays a list of components the user can install and the amount of disk 
 * space available and required.  The user can also select a destination 
 * folder.  \n\n** Not available in Visual C++ Edition ** 
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  
 * @param szMsg
 *   Enter the text you want to appear in the dialog box.  
 * @param svDir
 *   Enter the name of a folder you want to appear as the default folder.  This 
 *   variable contains the chosen folder after the function executes.  
 * @param szComponent
 *   The name of the component(s) you want to display.  If szComponent is a 
 *   null string (""), all components are displayed.  If szComponent is a 
 *   component name, just that component is displayed.  
 */
function LONG SdComponentDialog(STRING szTitle, STRING szMsg, BYREF STRING svDir, STRING szComponent);
/**
 * Displays a list of components and subcomponents the user can install.  
 * Also displays the amount of disk space available and required.  
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  
 * @param szMsg
 *   Enter the text you want to appear in the dialog box.  
 * @param szDir
 *   Enter the name of the target folder (destination location).  
 * @param szComponent
 *   The component(s) you want to display.  If szComponent is a null string 
 *   (""), all components and subcomponents are displayed.  If szComponent is a 
 *   component name, just that component and its subcomponents are displayed.  
 */
function LONG SdComponentDialog2(STRING szTitle, STRING szMsg, STRING szDir, STRING szComponent);
/**
 * Displays a list of components the user can install and the amount of disk 
 * space available and required.  The user can also select the destination 
 * folder.  \n\n** Not available in Visual C++ Edition ** 
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  
 * @param szMsg
 *   Enter the text you want to appear in the dialog box.  
 * @param svDir
 *   Enter the name of a folder you want to appear as the default folder.  This 
 *   parameter contains the chosen folder after the function executes.  
 * @param szComponent
 *   The name of the component(s) you want to display.  If szComponent is a 
 *   null string (""), all components are displayed.  If szComponent is a 
 *   component name, just that component is displayed.  
 */
function LONG SdComponentDialogAdv(STRING szTitle, STRING szMsg, BYREF STRING svDir, STRING szComponent);
/**
 * Displays a list of components and subcomponents the user can install and 
 * shows the amount of disk space available and required.  \n\n** Not 
 * available in Visual C++ Edition ** 
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  
 * @param szMsg
 *   Enter the text you want to appear in the dialog box.  
 * @param szDir
 *   Enter the destination location, typically TARGETDIR.  SdComponentMult uses 
 *   this location to calculate the free space, displayed in the dialog.  
 * @param szComponent
 *   The component(s) you want to display.  If szComponent is a null string 
 *   (""), all components and subcomponents are displayed.  If szComponent is a 
 *   component name, just that component and its subcomponents are displayed.  
 */
function LONG SdComponentMult(STRING szTitle, STRING szMsg, STRING szDir, STRING szComponent);
/**
 * Creates a dialog box that displays a folder for confirmation.  If Yes is 
 * clicked, the new folder is automatically created by this function.  
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  
 * @param szDir
 *   Enter the name of the folder to confirm.  You can use the information 
 *   returned by the SdAskDestPath function.  
 * @param nReserved
 *   Enter 0 (zero) in this parameter.  No other value is allowed.  
 */
function LONG SdConfirmNewDir(STRING szTitle, STRING szDir, NUMBER nReserved);
/**
 * Creates a dialog box that displays a folder for confirmation.  If Yes is 
 * clicked, the new folder is automatically created by this function.  \n\n** 
 * Not available in Visual C++ Edition ** 
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  
 * @param szName
 *   Enter the name returned by either the SdRegisterUser or the 
 *   SdRegisterUserEx function.  
 * @param szCompany
 *   Enter the company name returned by either the SdRegisterUser or the 
 *   SdRegisterUserEx function.  
 * @param szSerial
 *   Enter the serial number returned by the SdRegisterUserEx function.  If 
 *   ("") is entered, this field is cleared and no entry is displayed.  
 * @param nReserved
 *   Enter 0 (zero) in this parameter.  No other value is allowed.  
 */
function LONG SdConfirmRegistration(STRING szTitle, STRING szName, STRING szCompany, STRING szSerial, NUMBER nReserved);
/**
 * Creates a dialog box that displays information based on topic data.  The 
 * dialog box provides a heading and then topics of titles and descriptions.  
 * \n\n** Not available in Visual C++ Edition ** 
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  
 * @param szMsg
 *   Enter the message you want to appear in the Topics dialog box.  
 * @param listTopics
 *   Enter the name of a string list that contains the topic choices you want 
 *   to display.  
 * @param listDetails
 *   Enter the name of a string list that contains the descriptions of the 
 *   topics you want to display.  
 * @param nReserved
 *   Enter 0 (zero) in this parameter.  No other value is allowed.  
 */
function LONG SdDisplayTopics(STRING szTitle, STRING szMsg, LIST listTopics, LIST listDetails, NUMBER nReserved);
/**
 * Announces that the setup is complete and gives the user information or 
 * options.  
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  
 * @param szMsg1
 *   Enter the text to display at the top of the dialog box, informing the user 
 *   about the end of the setup.  
 * @param szMsg2
 *   Enter the text to display at the bottom of the dialog box, giving the user 
 *   information about what to do.  
 * @param szOpt1
 *   Enter the text to display beside the first check box.  Enter a null string 
 *   ("") to hide the check box.  
 * @param szOpt2
 *   Enter the text to display beside the second check box.  Enter a null 
 *   string ("") to hide the check box.  
 * @param bvOpt1
 *   Returns the selection state (TRUE or FALSE) of the first check box.  
 * @param bvOpt2
 *   Returns the selection state (TRUE or FALSE) of the second check box.  
 */
function LONG SdFinish(STRING szTitle, STRING szMsg1, STRING szMsg2, STRING szOpt1, STRING szOpt2, BYREF BOOL bvOpt1, BYREF BOOL bvOpt2);
/**
 * Announces that the setup is complete and gives the user the option to 
 * restart the system.  
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  
 * @param szMsg1
 *   Enter the text to display at the top of the dialog box, informing the user 
 *   about the end of the setup.  
 * @param nDefOption
 *   Specify a default radio button option selection.  
 *   <LI>SYS_BOOTWIN
 *   <LI>SYS_BOOTMACHINE
 *   <LI>0
 * @param szMsg2
 *   Enter the text to display at the bottom of the dialog box, giving the user 
 *   information about what to do.  
 * @param nReserved
 *   Enter 0 (zero) in this parameter.  No other value is allowed.  
 */
function LONG SdFinishReboot(STRING szTitle, STRING szMsg1, rul_RebootDialog_option nDefOption, STRING szMsg2, NUMBER nReserved);
/**
 * Displays a dialog box containing a license agreement in a multi-line edit 
 * field.  
 * @param szTitle
 *   Enter the text you want to display as the title of the dialog box.  
 * @param szMsg
 *   Enter the message you want to display in the static text field above the 
 *   multi-line edit field.  
 * @param szQuestion
 *   Enter the text you want to display in the static text field below the 
 *   multi-line edit field.  You would likely place a question here, to which 
 *   the user should respond by selecting either Yes and No.  
 * @param szLicenseFile
 *   Enter the filename of your license text file, which you specify in the 
 *   Setup Files pane of the project workspace.  
 */
function LONG SdLicense(STRING szTitle, STRING szMsg, STRING szQuestion, STRING szLicenseFile);
/**
 * Prepares a setup for Sd function calls by loading required resource 
 * strings, restoring the InstallShield window if it is minimized, and 
 * specifying Windows 95-style check boxes in Sd dialog boxes.  
 *   No parameters.  
 */
function LONG SdInit();
/**
 * Creates a section name for a custom dialog.  This section name is used in 
 * writing to and reading from an .iss file, which is used by InstallShield 
 * Silent.  \n\n** Not available in Visual C++ Edition ** 
 * @param svSection
 *   The section name (for example, "MyDlg-0").  InstallShield places a value 
 *   into this variable using the variables szDlg and nvDlgName.  This value is 
 *   used by SilentReadData and SilentWriteData.  
 * @param szDlg
 *   The name of the custom dialog (for example, "MyDlg") for which you are 
 *   creating a section name.  
 * @param szUnused
 *   This parameter is not used; you can enter a null string or an empty string 
 *   variable here.  
 * @param nvDlgName
 *   The counter that records the number of times SdMakeName is called for the 
 *   dialog named in szDlg.  InstallShield automatically increments this 
 *   counter.  Use a unique variable name for each custom dialog.  
 */
function LONG SdMakeName(BYREF STRING svSection, STRING szDlg, STRING szUnused, BYREF NUMBER nvDlgName);
/**
 * Displays a dialog box containing up to four bitmap buttons with 
 * accompanying text representing selection options.  SdOptionsButtons is 
 * ideal for allowing the user to choose a setup type.  \n\n** Not available 
 * in Visual C++ Edition ** 
 * @param szTitle
 *   The script dialog box title.  
 * @param szMsg
 *   The message you want to be displayed in the dialog box.  
 * @param listButtons
 *   The list of formatted strings specifying the bitmaps to be displayed on 
 *   the push buttons.  
 * @param listDescription
 *   The list strings forming the descriptions of the corresponding bitmaps in 
 *   the listButtons list.  
 */
function LONG SdOptionsButtons(STRING szTitle, STRING szMsg, LIST listButtons, LIST listDescription);
/**
 * Makes your product name available to all instances of the %P place holder.  
 * @param szProductName
 *   Enter the name of your product.  This name will appear by default wherever 
 *   %P appears in the appropriate static fields in Sd dialogs.  
 */
function LONG SdProductName(STRING szProductName);
/**
 * Creates a dialog box that retrieves the user name and company name.  
 * \n\n** Not available in Visual C++ Edition ** 
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  
 * @param szMsg
 *   Enter the text you want to appear in the dialog box.  This text is 
 *   considered a static control.  
 * @param svName
 *   Returns the name entered by the user.  You can use this information and 
 *   write it to another file or display it in a confirmation dialog if you 
 *   desire.  
 * @param svCompany
 *   Returns the company name entered by the user.  You can use this 
 *   information and write it to another file or display it in a confirmation 
 *   dialog if you desire.  
 */
function LONG SdRegisterUser(STRING szTitle, STRING szMsg, BYREF STRING svName, BYREF STRING svCompany);
/**
 * Creates a dialog box that retrieves the user name, company name, and 
 * serial number.  
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  
 * @param szMsg
 *   Enter the text you want to appear in the dialog box.  This text is 
 *   considered a static control.  
 * @param svName
 *   Returns the name entered by the user.  You can use this information and 
 *   write it to a file or display it in a confirmation dialog if you desire.  
 * @param svCompany
 *   Returns the company name entered by the user.  You can use this 
 *   information and write it to a file or display it in a confirmation dialog 
 *   if you desire.  
 * @param svSerial
 *   Returns the serial number entered by the user.  You can use this 
 *   information and write it to a file or display it in a confirmation dialog 
 *   if you desire.  
 */
function LONG SdRegisterUserEx(STRING szTitle, STRING szMsg, BYREF STRING svName, BYREF STRING svCompany, BYREF STRING svSerial);
/**
 * Displays program folders for selection.  SdSelectFolder allows you to 
 * offer a default selection.  The user can also enter a new folder name.  
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  
 * @param szMsg
 *   Enter the text you want to appear in the dialog box.  This text is 
 *   considered a static control.  
 * @param svDefGroup
 *   Returns the name of the selected folder.  
 */
function LONG SdSelectFolder(STRING szTitle, STRING szMsg, BYREF STRING svDefGroup);
/**
 * Displays a dialog box allowing the user to select from the standard setup 
 * types: Typical, Compact, and Custom.  \n\n** Not available in Visual C++ 
 * Edition ** 
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  
 * @param szMsg
 *   Enter the text you want to appear in the dialog box.  
 * @param svDir
 *   Returns the selected folder.  The user can select a folder using the 
 *   Browse button, which initiates the SelectDir function.  
 * @param nReserved
 *   Enter 0 (zero) in this parameter.  No other value is allowed.  
 */
function LONG SdSetupType(STRING szTitle, STRING szMsg, BYREF STRING svDir, NUMBER nReserved);
/**
 * Displays a dialog box allowing the user to select the setup from those 
 * defined in the current file media library.  
 * @param szTitle
 *   The title you wish to display in the SdSetupTypeEx dialog box.  
 * @param szMsg
 *   The message you wish to display in the SdSetupTypeEx dialog box.  
 * @param szReserved
 *   Enter a null string ("") in this parameter.  No other value is allowed.  
 * @param svSetupType
 *   SdSetupTypeEx returns the selected setup type in svSetupType.  
 * @param nStyle
 *   Enter zero in this parameter.  No other value is allowed.  
 */
function LONG SdSetupTypeEx(STRING szTitle, STRING szMsg, STRING szReserved, BYREF STRING svSetupType, NUMBER nStyle);
/**
 * Displays a custom or modified dialog box.  \n\n** Not available in Visual 
 * C++ Edition ** 
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  
 * @param szID
 *   Enter the string identifier that identifies the dialog.  If you enter a 
 *   null string ("") in this parameter, the function uses the value in nID.  
 * @param nID
 *   Enter the numeric value that identifies the dialog.  If you entered a 
 *   value in szID, this parameter is ignored.  
 * @param nReserved
 *   Enter 0 (zero) in this parameter.  No other value is allowed.  
 */
function LONG SdShowAnyDialog(STRING szTitle, STRING szID, NUMBER nID, NUMBER nReserved);
/**
 * Creates a general dialog box that displays a message and one single-line 
 * edit field.  You can specify a title for the dialog box.  \n\n** Not 
 * available in Visual C++ Edition ** 
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  If you 
 *   enter a null string (""), the default title ("Edit Data") is displayed.  
 * @param szMsg
 *   Enter the message you want to appear in the dialog box.  You can use the 
 *   %P place holder in your message string.  %P is replaced by the product 
 *   name made available by calling the SdProductName function.  
 * @param szField1
 *   Enter a name (up to 11 characters) to be displayed to the left of the 
 *   svEdit1 edit field.  
 * @param svEdit1
 *   This variable both initializes and saves the contents of the edit field.  
 */
function LONG SdShowDlgEdit1(STRING szTitle, STRING szMsg, STRING szField1, BYREF STRING svEdit1);
/**
 * Creates a general dialog box that displays a message and two single-line 
 * edit fields.  You can specify a title for the dialog box.  \n\n** Not 
 * available in Visual C++ Edition ** 
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  If you 
 *   enter a null string (""), the default title ("Edit Data") is displayed.  
 * @param szMsg
 *   Enter the message you want to appear in the dialog box.  You can use the 
 *   %P place holder in your message string.  %P is replaced by the product 
 *   name made available by calling the SdProductName function.  
 * @param szField1
 *   Enter a name (up to 11 characters) to be displayed to the left of the 
 *   svEdit1 edit field.  
 * @param szField2
 *   Enter a name (up to 11 characters) to be displayed to the left of the 
 *   svEdit2 edit field.  
 * @param svEdit1
 *   This variable both initializes and saves the contents of the first edit 
 *   field.  
 * @param svEdit2
 *   This variable both initializes and saves the contents of the second edit 
 *   field.  
 */
function LONG SdShowDlgEdit2(STRING szTitle, STRING szMsg, STRING szField1, STRING szField2, BYREF STRING svEdit1, BYREF STRING svEdit2);
/**
 * Creates a general dialog box that displays a message and three single-line 
 * edit fields.  You can specify a title for the dialog box.  \n\n** Not 
 * available in Visual C++ Edition ** 
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  If you 
 *   enter a null string (""), the default title ("Edit Data") is displayed.  
 * @param szMsg
 *   Enter the message you want to appear in the dialog box.  You can use the 
 *   %P place holder in your message string.  %P is replaced by the product 
 *   name made available by calling the SdProductName function.  
 * @param szField1
 *   Enter a name (up to 11 characters) to be displayed to the left of the 
 *   svEdit1 edit field.  
 * @param szField2
 *   Enter a name (up to 11 characters) to be displayed to the left of the 
 *   svEdit2 edit field.  
 * @param szField3
 *   Enter a name (up to 11 characters) to be displayed to the left of the 
 *   svEdit3 edit field.  
 * @param svEdit1
 *   This variable both initializes and saves the contents of the first edit 
 *   field.  
 * @param svEdit2
 *   This variable both initializes and saves the contents of the second edit 
 *   field.  
 * @param svEdit3
 *   This variable both initializes and saves the contents of the third edit 
 *   field.  
 */
function LONG SdShowDlgEdit3(STRING szTitle, STRING szMsg, STRING szField1, STRING szField2, STRING szField3, BYREF STRING svEdit1, BYREF STRING svEdit2, BYREF STRING svEdit3);
/**
 * Creates a dialog box that displays changes you want to make to a file.  
 * \n\n** Not available in Visual C++ Edition ** 
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  
 * @param szMsg
 *   Enter the message you want to appear in the dialog box.  
 * @param szTargetFile
 *   Enter the name of the file you want to modify.  This will be displayed 
 *   with the first radio button.  
 * @param szAltFile
 *   Enter an alternate name you may want to give the file if you decide to 
 *   make the changes.  This will be displayed with the second radio button.  
 * @param listChanges
 *   Enter the name of a string list that contains the list of changes you want 
 *   to make to the file.  This list is placed in a multi-line edit field that 
 *   allows you to select the changes to be implemented.  
 * @param nvSelection
 *   Returns the ID value of the selection.  
 */
function LONG SdShowFileMods(STRING szTitle, STRING szMsg, STRING szTargetFile, STRING szAltFile, LIST listChanges, BYREF NUMBER nvSelection);
/**
 * Create a dialog box that displays a list of scrollable messages.  
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  
 * @param szMsg
 *   Enter the message you want to appear above the information box.  
 * @param listID
 *   Enter the name of the list whose contents you want to appear in the dialog 
 *   box.  All messages that appear in the dialog box are read-only.  
 */
function LONG SdShowInfoList(STRING szTitle, STRING szMsg, LIST listID);
/**
 * Creates a general dialog box that displays a message or other information 
 * in a small window.  \n\n** Not available in Visual C++ Edition ** 
 * @param szMsg
 *   Enter the text you want to appear in the dialog box.  
 * @param bShow
 *   Specify TRUE to display the message box, and FALSE to remove it.  
 *   <LI>TRUE
 *   <LI>FALSE
 */
function LONG SdShowMsg(STRING szMsg, BOOL bShow);
/**
 * Creates a multi-line edit field displaying the settings and selections 
 * made during the setup.  
 * @param szTitle
 *   Enter the title you want to appear in the caption bar of the dialog box.  
 * @param szMsg
 *   Enter the message you want to appear in the static text field above the 
 *   multi-line edit field.  
 * @param listData
 *   Place the string list in which you have collected the information 
 *   retrieved from the user in the listData parameter.  SdStartCopy will 
 *   automatically place the strings separately into the mutli-line edit field.  
 */
function LONG SdStartCopy(STRING szTitle, STRING szMsg, LIST listData);
/**
 * Creates a general welcome dialog box.  
 * @param szTitle
 *   Enter the text you want to appear in the title of the dialog box.  
 * @param szMsg
 *   Enter the message you want to appear in the welcome dialog box.  
 */
function LONG SdWelcome(STRING szTitle, STRING szMsg);
/**
 * Repositions the file pointer within an open binary file.  \n\n** Not 
 * available in Visual C++ Edition ** 
 * @param nFileHandle
 *   Enter the file handle of a file opened in the binary mode.  
 * @param nBytes
 *   Enter the number of bytes you want to move the file pointer relative to 
 *   the position specified by nPosition.  
 * @param nPosition
 *   Specify where you want to move the pointer relative to where it is 
 *   currently located.  
 *   <LI>FILE_BIN_CUR
 *   <LI>FILE_BIN_END
 *   <LI>FILE_BIN_START
 */
function LONG SeekBytes(NUMBER nFileHandle, NUMBER nBytes, rul_SeekBytes_option nPosition);
private enum rul_SeekBytes_option {
   FILE_BIN_CUR
   FILE_BIN_END
   FILE_BIN_START
}
/**
 * Displays a dialog box that allows the user to select a target folder on 
 * which the application will be installed.  
 * @param szTitle
 *   Enter the text you want to display as the caption of this dialog box.  
 * @param szMsg
 *   Enter the message you want to display.  
 * @param svDir
 *   Enter the name of a folder you want to set as the default folder.  This 
 *   parameter will contain the chosen folder if you pressed the Browse push 
 *   button and selected an alternate folder.  
 * @param bCreate
 *   Specify whether you want to create the specified folder.  
 *   <LI>TRUE
 *   <LI>FALSE
 */
function LONG SelectDir(STRING szTitle, STRING szMsg, BYREF STRING svDir, BOOL bCreate);
/**
 * Displays a dialog box that allows the user to select from a list of 
 * folders.  
 * @param szTitle
 *   Enter the text you want as the title for the dialog box.  
 * @param szDefFolder
 *   Enter the name of the folder you want to specify as the default folder.  
 * @param svResultFolder
 *   Returns the name of the selected folder.  If the user enters a 
 *   non-existent folder name, it will still be returned in this parameter, but 
 *   remember that this function cannot create the folder.  
 */
function LONG SelectFolder(STRING szTitle, STRING szDefFolder, BYREF STRING svResultFolder);
/**
 * Sends a message to one or more windows.  \n\n** Not available in Visual 
 * C++ Edition ** 
 * @param nHwnd
 *   Enter the handle that identifies the window you want to receive the 
 *   message.  
 * @param nMsg
 *   Enter the message you want to send to the window(s).  
 * @param nwParam
 *   Enter any additional message information.  
 * @param nlParam
 *   Enter any additional message information.  
 */
function LONG SendMessage(NUMBER nHwnd, NUMBER nMsg, NUMBER nwParam, NUMBER nlParam);
/**
 * Sets the color of the main setup window or the status bar (in the progress 
 * indicator).  
 * @param nObject
 *   Specify which user interface object you want to change.  
 *   <LI>BACKGROUND
 *   <LI>STATUSBAR
 * @param nColor
 *   Specify the color you want to apply to the user interface objects.  You 
 *   can specify the color using the constants listed below or by calling the 
 *   RGB function (also in the list) in this parameter position.  
 *   <LI>BK_BLUE
 *   <LI>BK_GREEN
 *   <LI>BK_MAGENTA
 *   <LI>BK_RED
 *   <LI>BK_YELLO
 *   <LI>BK_SOLIDBLUE
 *   <LI>BK_SOLIDGREEN
 *   <LI>BK_SOLIDMAGENTA
 *   <LI>BK_SOLIDRED
 *   <LI>BK_SOLIDYELLOW
 *   <LI>BK_SMOOTH
 *   <LI>GREEN
 *   <LI>RED
 *   <LI>BLUE
 *   <LI>MAGENTA
 *   <LI>YELLOW
 *   <LI>RGB(constRed, constGreen, constBlue)
 */
function LONG SetColor(rul_SetColor_option nObject, rul_color nColor);
private enum rul_SetColor_option {
   BACKGROUND
   STATUSBAR
}
private enum rul_color {
   BK_BLUE
   BK_GREEN
   BK_MAGENTA
   BK_MAGENTA1
   BK_ORANGE
   BK_RED
   BK_YELLO
   BK_SOLIDBLACK
   BK_SOLIDBLUE
   BK_SOLIDGREEN
   BK_SOLIDMAGENTA
   BK_SOLIDORANGE
   BK_SOLIDPINK
   BK_SOLIDRED
   BK_SOLIDWHITE
   BK_SOLIDYELLOW
   BK_SMOOTH
   BK_YELLOW
   GREEN
   RED
   BLACK
   BLUE
   MAGENTA
   YELLOW
   "RGB()"
}
/**
 * Changes the titles that appear in the title bars of some common built-in 
 * dialog boxes.  
 * @param nDialogId
 *   Identify the built-in dialog box whose title you are changing.  
 *   <LI>DLG_ASK_OPTIONS
 *   <LI>DLG_ASK_PATH
 *   <LI>DLG_ASK_TEXT
 *   <LI>DLG_ASK_YESNO
 *   <LI>DLG_ENTER_DISK
 *   <LI>DLG_MSG_INFORMATION
 *   <LI>DLG_MSG_SEVERE
 *   <LI>DLG_STATUS
 *   <LI>DLG_MSG_WARNING
 *   <LI>DLG_USER_CAPTION
 * @param szTitle
 *   Enter the text you want as the new title.  
 */
function LONG SetDialogTitle(rul_SetDialogTitle_option nDialogId, STRING szTitle);
private enum rul_SetDialogTitle_option {
   DLG_ASK_OPTIONS
   DLG_ASK_PATH
   DLG_ASK_TEXT
   DLG_ASK_YESNO
   DLG_ENTER_DISK
   DLG_MSG_INFORMATION
   DLG_MSG_SEVERE
   DLG_STATUS
   DLG_MSG_WARNING
   DLG_USER_CAPTION
}
/**
 * Sets the display effect for bitmap or metafile images.  \n\n** Not 
 * available in Visual C++ Edition ** 
 * @param nEffect
 *   Choose a display effect option.  
 *   <LI>EFF_FADE
 *   <LI>EFF_REVEAL
 *   <LI>EFF_HORZREVEAL
 *   <LI>EFF_HORZSTRIPE
 *   <LI>EFF_VERTSTRIPE
 *   <LI>EFF_BOXSTRIPE
 *   <LI>EFF_NONE
 */
function LONG SetDisplayEffect(rul_SetDisplayEffect_option nEffect);
private enum rul_SetDisplayEffect_option {
   EFF_FADE
   EFF_REVEAL
   EFF_HORZREVEAL
   EFF_HORZSTRIPE
   EFF_VERTSTRIPE
   EFF_BOXSTRIPE
   EFF_NONE
}
/**
 * Customizes InstallShield default error messages.  
 * @param nErrorID
 *   Specify which error message you want to customize.  
 *   <LI>ERR_BOX_BADPATH
 *   <LI>ERR_BOX_BADTAGFILE
 *   <LI>ERR_BOX_DISKID
 *   <LI>ERR_BOX_DRIVEOPEN
 *   <LI>ERR_BOX_READONLY
 *   <LI>ERR_BOX_NOSPACE
 * @param szText
 *   Enter the error message you want to appear in the message box.  
 */
function LONG SetErrorMsg(rul_error_flag nErrorID, STRING szText);
private enum rul_error_flag {
   ERR_BADPATH
   ERR_BADTAGFILE
   ERR_BOX_BADPATH
   ERR_BOX_BADTAGFILE
   ERR_BOX_DISKID
   ERR_BOX_DRIVEOPEN
   ERR_BOX_EXIT
   ERR_BOX_HELP
   ERR_BOX_NOSPACE
   ERR_BOX_PAUSE
   ERR_BOX_READONLY
   ERR_DISKID
   ERR_DRIVEOPEN
}
/**
 * Specifies custom text for the caption bar of InstallShield's built-in 
 * error message boxes.  
 * @param nErrorID
 *   Specify the error message box whose title you want to customize.  
 *   <LI>ERR_BOX_BADPATH
 *   <LI>ERR_BOX_BADTAGFILE
 *   <LI>ERR_BOX_DISKID
 *   <LI>ERR_BOX_DRIVEOPEN
 *   <LI>ERR_BOX_READONLY
 *   <LI>ERR_BOX_NOSPACE
 * @param szText
 *   Enter the error message you want to appear in the error message box.  
 */
function LONG SetErrorTitle(rul_error_flag nErrorID, STRING szText);
/**
 * Sets a file's date, time, or attributes.  Attributes indicate whether the 
 * file is normal, archived, hidden, read-only, or system.  
 * @param szPathFile
 *   Enter the path and filename of the file whose characteristic you want to 
 *   change.  
 * @param nType
 *   Specify which file characteristic to change.  
 *   <LI>FILE_ATTRIBUTE
 *   <LI>FILE_DATE
 *   <LI>FILE_TIME
 * @param nResult
 *   Enter the new values that you want in nResult.  To change the file's date 
 *   or time, enter 0.  To change the file's access attributes, enter one of 
 *   the other constants.  
 *   <LI>0
 *   <LI>FILE_ATTR_ARCHIVED
 *   <LI>FILE_ATTR_HIDDEN
 *   <LI>FILE_ATTR_NORMAL
 *   <LI>FILE_ATTR_READONLY
 *   <LI>FILE_ATTR_SYSTEM
 * @param szResult
 *   Enter the new or existing file date or time.  Date format is YYYY/MM/DD.  
 *   Time format is HH:MM:SS, using a 24-hour clock format, with midnight at 
 *   00:00:00 or 24:00:00.  Seconds must be a multiple of 2.  
 */
function LONG SetFileInfo(STRING szPathFile, rul_SetFileInfo_type nType, rul_SetFileInfo_flag nResult, STRING szResult);
private enum rul_SetFileInfo_type {
   FILE_ATTRIBUTE
   FILE_DATE
   FILE_TIME
}
private enum rul_SetFileInfo_flag {
   0
   FILE_ATTR_ARCHIVED
   FILE_ATTR_DIRECTORY
   FILE_ATTR_HIDDEN
   FILE_ATTR_NORMAL
   FILE_ATTR_READONLY
   FILE_ATTR_SYSTEM
}
/**
 * Sets the font and style when displaying text strings.  You may use 
 * standard Windows fonts with this function.  
 * @param nItemID
 *   Specify the item whose font and font style you want to set.  One option is 
 *   currently allowed.  
 * @param nFontStyle
 *   Specify the font style(s).  You can combine all styles (except 
 *   STYLE_NORMAL) with the bitwise OR operator ( | ).  
 *   <LI>STYLE_NORMAL
 *   <LI>STYLE_BOLD
 *   <LI>STYLE_ITALIC
 *   <LI>STYLE_SHADOW
 *   <LI>STYLE_UNDERLINE
 * @param szFontName
 *   Enter the name of an available Windows font.  Valid font names include 
 *   Courier, Helv, Helvetica, Modern, Roman, Script, Terminal, Times, and 
 *   TmsRmn.  Consult Windows SDK documentation for available fonts.  
 */
function LONG SetFont(NUMBER nItemID, rul_SetFont_flags nFontStyle, STRING szFontName);
private enum rul_SetFont_flags {
   STYLE_NORMAL
   STYLE_BOLD
   STYLE_ITALIC
   STYLE_SHADOW
   STYLE_UNDERLINE
}
/**
 * Enables the progress indicator and allows you to set an initial percentage 
 * number for the progress bar.  
 * @param nPercent
 *   Enter a number that reflects the percentage of the setup process that is 
 *   complete at that point in the script.  This number will be the initial 
 *   progress bar setting for the particular stage of the setup.  
 * @param szString
 *   Enter a brief message that explains which file is being copied or what the 
 *   setup program is doing.  The string is displayed in the upper left-hand 
 *   corner of the progress indicator.  
 */
function LONG SetStatusWindow(NUMBER nPercent, STRING szString);
/**
 * Displays a title in large text on the main window.  The title appears in 
 * the top-left corner of the window.  You can also use the SetTitle function 
 * to set the caption on the title bar of the main window.  
 * @param szString
 *   Enter the string you want to use as the title.  The title must be a single 
 *   line of text, no more than 80 characters in length.  
 * @param nPointSize
 *   Enter the size, in points, of the text you want.  The recommended size is 
 *   28 points.  Experiment to see which size you like best.  
 * @param nColor
 *   Set the color of the text.  You can specify the color using the constants 
 *   listed below or by calling the RGB function (alos in the list) in this 
 *   parameter position.  
 *   <LI>RED
 *   <LI>GREEN
 *   <LI>BLUE
 *   <LI>MAGENTA
 *   <LI>YELLOW
 *   <LI>WHITE
 *   <LI>BACKGROUNDCAPTION
 *   <LI>RGB(constRed, constGreen, constBlue)
 */
function LONG SetTitle(STRING szString, NUMBER nPointSize, rul_fgcolor nColor);
private enum rul_fgcolor {
   RED
   GREEN
   BLUE
   MAGENTA
   YELLOW
   WHITE
   BACKGROUNDCAPTION
   "RGB()"
}
/**
 * Creates a simple dialog box that gives the user a choice of standard setup 
 * types: Typical, Compact, or Custom.  
 * @param szTitle
 *   Enter the text you want to use as the title of this dialog.  
 * @param szMsg
 *   Enter the message you want to display at the top of the dialog box.  If 
 *   you use a null string ("") in this parameter, InstallShield will display a 
 *   default message.  
 * @param szReserved
 *   Enter a null string ("") in this parameter.  No other value is allowed.  
 * @param nType
 *   Enter the default setup type when the dialog box is first displayed.  
 *   <LI>TYPICAL
 *   <LI>COMPACT
 *   <LI>CUSTOM
 * @param nReserved
 *   Enter zero in this parameter.  No other value is allowed.  
 */
function LONG SetupType(STRING szTitle, STRING szMsg, STRING szReserved, rul_SetupType_option nType, NUMBER nReserved);
private enum rul_SetupType_option {
   TYPICAL
   COMPACT
   CUSTOM
}
/**
 * Displays or moves a Program Manager folder window.  Use this function at 
 * the end of the setup to make the new program folder and its program icons 
 * visible.  
 * @param szGrpName
 *   Enter the name of the program folder you want to display.  
 * @param nCommand
 *   Specify how you want the folder window to be displayed.  
 *   <LI>SW_NORMAL
 *   <LI>SW_MAXIMIZE
 *   <LI>SW_MINIMIZE
 *   <LI>SW_SHOW
 *   <LI>SW_SHOWMINIMIZED
 *   <LI>SW_SHOWMINNOACTIVE
 *   <LI>SW_SHOWNA
 *   <LI>SW_SHOWNOACTIVATE
 */
function LONG ShowGroup(STRING szGrpName, rul_ShowGroup_option nCommand);
private enum rul_ShowGroup_option {
   SW_NORMAL
   SW_MAXIMIZE
   SW_MINIMIZE
   SW_SHOW
   SW_SHOWMAXIMIZED
   SW_SHOWMINIMIZED
   SW_SHOWMINNOACTIVE
   SW_SHOWNA
   SW_SHOWNOACTIVATE
}
/**
 * Displays a program folder.  
 * @param szFolder
 *   Enter the name of the folder you want to display.  
 * @param nCommand
 *   Specifies the state of the folder.  
 *   <LI>SW_SHOW
 *   <LI>SW_MAXIMIZE
 *   <LI>SW_MINIMIZE
 *   <LI>SW_RESTORE
 */
function LONG ShowProgramFolder(STRING szFolder, rul_ShowProgramFolder_option nCommand);
private enum rul_ShowProgramFolder_option {
   SW_SHOW
   SW_MAXIMIZE
   SW_MINIMIZE
   SW_RESTORE
}
/**
 * Instructs InstallShield Silent on how to read the .iss file dialog data 
 * for a custom dialog box when a setup runs in silent mode.  \n\n** Not 
 * available in Visual C++ Edition ** 
 * @param szSection
 *   The name of the dialog data section in the .iss file.  
 * @param szValName
 *   The value name appearing in the dialog data section of the .iss file.  
 *   Every dialog has at least one value for szValName - "Result" - which 
 *   identifies the value returned by the dialog box push button controls.  
 * @param nValType
 *   Specify the data type of the value assigned to the value name in 
 *   szValName.  The value itself is stored in either szVal or nVal, depending 
 *   upon the value of nValType.  
 *   <LI>DATA_STRING
 *   <LI>DATA_NUMBER
 *   <LI>DATA_COMPONENT
 *   <LI>DATA_LIST
 * @param svVal
 *   The value assigned to the value name in szValName when nValType is 
 *   DATA_STRING or DATA_COMPONENT.  
 * @param nvVal
 *   The value assigned to the value name in szValName when nValType is 
 *   DATA_NUMBER or DATA_LIST.  
 */
function LONG SilentReadData(STRING szSection, STRING szValName, rul_val_type nValType, BYREF STRING svVal, BYREF NUMBER nvVal);
private enum rule_val_type {
   DATA_STRING
   DATA_NUMBER
   DATA_COMPONENT
   DATA_LIST
}
/**
 * Records selections made in custom dialogs during the setup.  \n\n** Not 
 * available in Visual C++ Edition ** 
 * @param szSection
 *   The name of the dialog data section in the .iss file.  Do not include the 
 *   square brackets ( [ ] ).  
 * @param szValName
 *   The value name appearing in the dialog data section of the .iss file.  
 * @param nValType
 *   Specify the data type of the value assigned to the value name in 
 *   szValName.  The value itself is stored in either szVal or nVal, depending 
 *   upon the value of nValType.  
 *   <LI>DATA_STRING
 *   <LI>DATA_NUMBER
 *   <LI>DATA_COMPONENT
 *   <LI>DATA_LIST
 * @param szVal
 *   The value assigned to the value name in szValName when nValType is 
 *   DATA_STRING or DATA_COMPONENT.  
 * @param nVal
 *   The value assigned to the value name in szValName when nValType is 
 *   DATA_NUMBER or DATA_LIST.  
 */
function LONG SilentWriteData(STRING szSection, STRING szValName, ru_val_type nValType, STRING szVal, NUMBER nVal);
/**
 * Changes the size of a specific user interface object.  You specify the new 
 * size in pixels.  
 * @param nObject
 *   Enter the object you want to size.  
 *   <LI>BACKGROUND
 *   <LI>METAFILE
 *   <LI>MMEDIA_AVI
 * @param nDx
 *   Enter the horizontal size of the object in pixels.  
 * @param nDy
 *   Enter the vertical size of the object in pixels.  
 */
function LONG SizeWindow(rul_SizeWindow_option nObject, NUMBER nDx, NUMBER nDy);
private enum rul_SizeWindow_option {
   BACKGROUND
   METAFILE
   MMEDIA_AVI
}
/**
 * Creates a string from variable data using format specifier expressions and 
 * matching variables.  
 * @param svResult
 *   Contains the formatted string returned by Sprintf.  
 * @param szFormat
 *   Enter a string containing a valid format specification(s).  
 * @param arg
 *   Enter an argument(s) corresponding to the format specification(s) in 
 *   szFormat.  
 */
function LONG Sprintf(BYREF STRING svResult, STRING szFormat, arg[, ...]);
/**
 * Formats and displays a series of characters and/or values in a message 
 * box.  
 * @param nType
 *   Specify the message box type.  
 *   <LI>INFORMATION
 *   <LI>SEVERE
 *   <LI>WARNING
 * @param szTitle
 *   The title of the message box.  
 * @param szFormat
 *   Enter a string containing a valid format specification(s).  
 * @param arg
 *   Enter an argument(s) corresponding to the format specification(s) in 
 *   szFormat.  
 */
function LONG SprintfBox(rul_MessageBox_type nType, STRING szTitle, STRING szFormat, arg[, ...]);
/**
 * Sets the percent value to be displayed in the progress indicator at the 
 * end of the next file transfer operation.  
 * @param bLink
 *   Specify whether or not you want to link the information gauge to the 
 *   progress indicator.  
 *   <LI>ON
 *   <LI>OFF
 * @param nFinalPercent
 *   Enter the final percentage value you want to appear in the progress 
 *   indicator following the call to StatusUpdate.  InstallShield evenly 
 *   updates the progress bar from the current to the nFinalPercent value.  
 */
function LONG StatusUpdate(rul_on_off bLink, NUMBER nFinalPercent);
private enum rul_on_off {
   ON
   OFF
}
/**
 * Performs a lexicographic comparison of two strings.  It is not 
 * case-sensitive.  
 * @param szStringA
 *   Enter the first string to compare.  
 * @param szStringB
 *   Enter the second string to compare.  
 */
function LONG StrCompare(STRING szStringA, STRING szStringB);
/**
 * Determines if one string contains another string.  
 * @param szString
 *   Enter the string which you want to search for the szFindMe string.  
 * @param szFindMe
 *   Enter the string you are searching for.  
 */
function LONG StrFind(STRING szString, STRING szFindMe);
/**
 * Separates a string into a list of tokens.  \n\n** Not available in Visual 
 * C++ Edition ** 
 * @param listID
 *   Enter the ID of a list you want to use to store the tokens.  Before you 
 *   use StrGetTokens, you need to create this list with the ListCreate 
 *   function.  After the StrGetTokens function executes, each element of this 
 *   list contains one token.  
 * @param szString
 *   Enter the string containing the tokens you want to separate.  
 * @param szDelimiterSet
 *   Enter a set of one or more delimiters.  Each delimiter is one character (1 
 *   byte).  If you enter a null string, the function searches for NULL 
 *   characters as the delimiters.  This is useful if you are using the 
 *   GetProfString function.  
 */
function LONG StrGetTokens(LIST listID, STRING szString, STRING szDelimiterSet);
/**
 * Finds the length of a string.  
 * @param szString
 *   Enter the string for which you want to determine the length.  
 */
function LONG StrLength(STRING szString);
/**
 * Removes the last backslash from a string.  
 * @param svString
 *   Enter the string that contains the backslash you want to remove.  After 
 *   the function executes, this parameter will contain the modified string 
 *   (without the last backslash).  
 */
function LONG StrRemoveLastSlash(BYREF STRING svString);
/**
 * Extracts part of a string.  StrSub allows you to specify the source string 
 * you wish to extract from, the position at which to begin the extraction, 
 * and the number of characters you want to extract.  
 * @param svSubStr
 *   Returns the string extracted by the function.  
 * @param szString
 *   Enter the source string.  
 * @param nStart
 *   Enter the numeric position at which you want to start extracting the 
 *   substring.  The position of the first character in szString is 0 (zero).  
 * @param nLength
 *   Enter the number of characters you want to copy from szString.  This 
 *   number cannot exceed the length of the source string.  
 */
function LONG StrSub(BYREF STRING svSubStr, STRING szString, NUMBER nStart, NUMBER nLength);
/**
 * Converts all the letters in a string to lowercase.  This function does not 
 * affect non-alphabetic characters.  
 * @param svTarget
 *   Returns the converted string in lowercase letters.  
 * @param szSource
 *   Enter the string you want to convert to all lowercase.  
 */
function LONG StrToLower(BYREF STRING svTarget, STRING szSource);
/**
 * Converts a string into a number.  StrToNum is similar to the C function 
 * atoi (ASCII to integer).  
 * @param nvVar
 *   Returns the converted number.  
 * @param szString
 *   Enter the numeric string you want to convert into a number.  szString 
 *   cannot contain letters.  
 */
function LONG StrToNum(BYREF NUMBER nvVar, STRING szString);
/**
 * Converts all the letters in a string to uppercase.  This function does not 
 * affect non-alphabetic characters.  
 * @param svTarget
 *   Returns the converted string in uppercase letters.  
 * @param szSource
 *   Enter the string you want to convert to all uppercase.  
 */
function LONG StrToUpper(BYREF STRING svTarget, STRING szSource);
/**
 * Restarts Windows or reboots the system.  
 * @param nOp
 *   Specify which action you want to perform after terminating the setup.  
 *   <LI>SYS_BOOTMACHINE
 *   <LI>SYS_BOOTWIN
 *   <LI>SYS_TODOS
 */
function LONG System(rul_System_option nOp);
private enum rul_System_option {
   SYS_BOOTMACHINE
   SYS_BOOTWIN
   SYS_TODOS
   SYS_BOOTWIN_INSTALL
   SYS_RESTART
   SYS_SHUTDOWN
}
/**
 * Unloads a DLL from memory when you are done using the DLL.  \n\n** Not 
 * available in Visual C++ Edition ** 
 * @param szDLLName
 *   Enter the filename of the DLL.  Do not include the path in this parameter.  
 */
function LONG UnUseDLL(STRING szDLLName);
/**
 * Loads a DLL into memory.  You must load the DLL into memory before you can 
 * call any function in the DLL from the script.  If the loaded DLL accesses 
 * other DLLs, ensure that the other DLLs are in SUPPORTDIR.  \n\n** Not 
 * available in Visual C++ Edition ** 
 * @param szDLLName
 *   Enter the fully qualified path and filename of the DLL you want to load 
 *   into memory.  
 */
function LONG UseDLL(STRING szDLLName);
/**
 * Restores the SRCDIR and TARGETDIR system variables saved by the VarSave 
 * function.  
 *   and TARGETDIR system variables.  
 */
function LONG VarRestore(NUMBER nType);
/**
 * Saves the current value of the SRCDIR and TARGETDIR system variables.  
 *   system variables.  
 */
function LONG VarSave(NUMBER nType);
/**
 * Compares two strings that contain version information.  
 * @param szVersionInfo1
 *   Enter the first version string in this format: Major version number.  
 *   Minor version number.  
 * @param szVersionInfo2
 *   Enter the second version string in the same format.  
 * @param nCompareFlag
 *   Enter the constant VERSION to specify you are comparing version numbers.  
 *   You cannot enter any other constant in this parameter.  
 */
function LONG VerCompare(STRING szVersionInfo1, STRING szVersionInfo2, NUMBER nCompareFlag);
/**
 * Searches for a specified file and retrieves the file version and location.  
 * @param szFileName
 *   Enter only the name of the file whose version you want to find.  You 
 *   cannot specify a path in this parameter.  
 * @param svPath
 *   Returns the fully qualified path of the file, if found.  
 * @param svVersionNumber
 *   Returns the version number of the file, if found, in the following format: 
 *   Major version number.  Minor version number.  
 */
function LONG VerFindFileVersion(STRING szFileName, BYREF STRING svPath, BYREF STRING svVersionNumber);
/**
 * Retrieves the version of a specified file.  
 * @param szFileName
 *   Enter the fully qualified path and filename of the file whose version 
 *   number you want to retrieve.  
 * @param svVersionNumber
 *   Returns the version number in this format: Major version number.Minor 
 *   version number.  
 */
function LONG VerGetFileVersion(STRING szFileName, BYREF STRING svVersionNumber);
/**
 * Searches for the specified file and installs a newer version of the file 
 * if necessary.  
 * @param szFileName
 *   Enter only the name of the file you want to install.  You cannot include 
 *   path information in this parameter.  
 * @param nUpdateFlag
 *   Specifies whether the file should be updated unconditionally or only if 
 *   the version of the file found on the target system is older than the 
 *   version of the file that you have shipped.  
 *   <LI>VER_UPDATE_COND
 *   <LI>VER_UPDATE_ALWAYS
 * @param svInstalledFile
 *   Contains the fully qualified path and filename of the file installed by 
 *   the function.  
 */
function LONG VerSearchAndUpdateFile(STRING szFileName, rul_update_flag nUpdateFlag, BYREF STRING svInstalledFile);
private enum rul_update_flag {
   VER_UPDATE_COND
   VER_UPDATE_FILE
}
/**
 * Uses the version information of a specified file to determine whether or 
 * not to install the file on the target folder.  
 * @param szFileName
 *   Enter the name of the target file--the file on the target system that you 
 *   want to update.  
 * @param nUpdateFlag
 *   Specify how to update the file.  You can combine options with the bitwise 
 *   OR operator ( | ).  You cannot combine SHAREDFILE with LOCKEDFILE.  
 *   <LI>LOCKEDFILE
 *   <LI>SHAREDFILE
 *   <LI>SELFREGISTER
 *   <LI>VER_UPDATE_ALWAYS
 *   <LI>VER_UPDATE_COND
 * @param svInstalledFilePath
 *   Returns the fully qualified path and filename of the file that the 
 *   function installed.  
 */
function LONG VerUpdateFile(STRING szFileName, NUMBER nUpdateFlag, BYREF STRING svInstalledFilePath);
private enum rul_update_file_flag {
   LOCKEDFILE
   SHAREDFILE
   SELFREGISTER
   VER_UPDATE_ALWAYS
   VER_UPDATE_COND
}
/**
 * Displays a custom dialog box.  You can write your script to handle 
 * different responses from the user based on the return value from this 
 * function.  \n\n** Not available in Visual C++ Edition ** 
 * @param szDlgName
 *   Enter the ID of the dialog box you want to display.  
 */
function LONG WaitOnDialog(STRING szDlgName);
/**
 * Creates and displays the welcome dialog box.  
 * @param szTitle
 *   Enter the text you want to appear as the title of this dialog box.  
 * @param nReserved
 *   Enter 0 (zero) in this parameter.  No other value is allowed.  
 */
function LONG Welcome(STRING szTitle, NUMBER nReserved);
/**
 * Writes a specific number of bytes to a file opened in the binary mode.  
 * \n\n** Not available in Visual C++ Edition ** 
 * @param nFile
 *   Enter the file handle of the file opened in binary mode.  
 * @param svString
 *   The string containing the bytes you want to write to the output file.  
 * @param nIndex
 *   Enter the starting location in svString where the bytes are written to the 
 *   output file.  The first byte is at index location 0.  
 * @param nBytes
 *   Enter the number of bytes you want to write to the output file.  
 */
function LONG WriteBytes(NUMBER nFile, BYREF STRING svString, NUMBER nIndex, NUMBER nBytes);
/**
 * Writes a line of text to a text file opened in append mode.  
 * @param nvFileHandle
 *   Enter the file handle of an open file.  The handle is obtained from the 
 *   OpenFile or CreateFile function.  
 * @param szLine
 *   Enter a string containing the text you want to write to the file.  
 */
function LONG WriteLine(BYREF NUMBER nvFileHandle, STRING szLine);
/**
 * Writes a profile string to a specific INI file.  \n\n** Not available in 
 * Visual C++ Edition ** 
 * @param szFileName
 *   Enter the fully qualified path and filename of the INI file.  If the INI 
 *   file does not exist, this function creates the file.  The specified folder 
 *   must already exist.  
 * @param szSectionName
 *   Enter the name of the section where szValue will be copied.  Do not 
 *   include section name delimiting brackets ( [] ).  If the section does not 
 *   exist, this function creates it for you.  This parameter is 
 *   case-independent.  
 * @param szKeyName
 *   Enter the key you want to associate with szValue.  
 * @param szValue
 */
function LONG WriteProfString(STRING szFileName, STRING szSectionName, STRING szKeyName, STRING szValue);
/**
 * Copies a file or files from the source folder to the target folder.  
 * @param szSrcFile
 *   Enter the name of file you want to copy.  You can copy multiple files 
 *   using wild card characters in this parameter, but you cannot include a 
 *   path.  This parameter uses SRCDIR as its path.  
 * @param szTargetFile
 *   Currently, szTargetFile is ignored.  However, a string value must be 
 *   present.  Enter a null string or wildcard expression such as "*.*".  
 * @param nOp
 *   Specify the type of copy operation you want to perform.  You can combine 
 *   options with the bitwise OR operator ( | ).  You cannot combine SHAREDFILE 
 *   with LOCKEDFILE.  
 *   <LI>COMP_NORMAL
 *   <LI>COMP_UPDATE_SAME
 *   <LI>COMP_UPDATE_DATE
 *   <LI>COMP_UPDATE_VERSION
 *   <LI>SELFREGISTER
 *   <LI>SHAREDFILE
 *   <LI>LOCKEDFILE
 *   <LI>EXCLUDE_SUBDIR
 *   <LI>INCLUDE_SUBDIR
 */
function LONG XCopyFile(STRING szSrcFile, STRING szTargetFile, rul_copy_option nOp);
private enum rul_copy_option {
   COMP_NORMAL
   COMP_UPDATE_SAME
   COMP_UPDATE_DATE
   COMP_UPDATE_DATE_NEWER
   COMP_UPDATE_VERSION
   SELFREGISTER
   SHAREDFILE
   LOCKEDFILE
   EXCLUDE_SUBDIR
   INCLUDE_SUBDIR
   XCOPY_DATETIME
}



/** 
 * This system variable is set to TRUE if InstallShield encounters a 
 * locked file while transferring files with the LOCKEDFILE or SHAREDFILE 
 * option.  If BATCH_INSTALL is set to TRUE, you must call {@link CommitSharedFiles}
 * or {@link SdFinishReboot} so that the system will update the files when it is next 
 * rebooted.  If BATCH_INSTALL is set to FALSE, no locked files were found 
 * and the setup process can terminate normally.
 */ 
BOOL BATCH_INSTALL;

/**
 * Setup.exe accepts user-defined command line arguments and assigns them to
 * the system string variable CMDLINE.  Note the following important points:
 * <UL>
 * <LI>User-defined command line arguments must be specified before
 *     any InstallShield command line switches.
 * <LI>InstallShield command line switches are not copied to CMDLINE.
 * </UL>
 * For more information about Setup.exe command line switches,
 * refer to the online Help Library.
 */
STRING CMDLINE;

/**
 * This system variable contains the fully qualified name of the folder
 * defined by Windows to store files shared by applications that are
 * installed on the system.  In English Windows, that folder is named "Common
 * Files" and is located in the program files folder.  (In other language
 * versions of Windows, the common files folder name is localized
 * appropriately by default.) The common files folders is the recommended
 * default location for folders that are shared by applications.
 * <P>
 * The value of the InstallShield system variable COMMONFILES is obtained
 * from the key "CommonFilesDir" in the Windows registry during setup
 * initialization.
 */
STRING COMMONFILES;

/**
 * This system variable stores the name of the file that was involved in an
 * error.  For example, if an error occurs while copying a specific file with
 * a built-in function, InstallShield will set ERRORFILENAME to the name of
 * the file that caused the error.  Not all file-operation functions use
 * ERRORFILENAME.
 */
STRING ERRORFILENAME;

/**
 * This system variable stores the fully qualified path to the Desktop
 * folder, which holds the program folders and items that are displayed on
 * the user's desktop.
 * <P>
 * The value of FOLDER_DESKTOP changes as follows to ensure that groups and
 * folders are created at the proper location on all Explorer shell operating
 * systems.
 * <UL>
 * <LI>Under Windows NT 4.0, the location pointed to by FOLDER_DESKTOP
 * changes when the default group/folder type is changed from Common to
 * Personal or Personal to Common by calling {@link ProgDefGroupType}.
 * <LI>Under Windows 95 and later, the location pointed to by FOLDER_DESKTOP
 * does not change unless the current user logs out and a different user logs
 * in.  Note that this value will change only if user profiles have been
 * enabled; otherwise the default FOLDER_DESKTOP location is used for all
 * users.
 * </UL>
 * <B>Note:</B>
 * Once user profiles have been enabled on Windows 95 or later,
 * FOLDER_PROGRAMS cannot be set to the default location; it will always
 * point to the current user's desktop folder location.  For that reason, it
 * is not possible to install common software on Windows 95 or later once
 * profiles have been enabled.  This is a limitation of Windows.
 */
STRING FOLDER_DESKTOP;

/**
 * This system variable stores the fully qualified path to the Start
 * Menu\Programs folder, which is displayed when you select Programs from the
 * Start Menu.  Note that the menu uses the small version of group, folder,
 * and program icons.
 * <P>
 * The value of FOLDER_PROGRAMS changes as follows to ensure that groups and
 * folders are created at the proper location on all Explorer shell operating
 * systems.
 * <UL>
 * <LI>Under Windows NT 4.0, the location pointed to by FOLDER_PROGRAMS changes
 * when the default group/folder type is changed from Common to Personal or
 * Personal to Common by calling {@link ProgDefGroupType}.
 * <LI>Under Windows 95 and later, the location pointed to by FOLDER_PROGRAMS
 * does not change unless the current user logs out and a different user logs
 * in.  Note that this value will change only if user profiles have been
 * enabled; otherwise the default FOLDER_PROGRAMS location is used for all
 * users.
 * </UL>
 * <B>Note:</B>
 * Once user profiles have been enabled on Windows 95 or later,
 * FOLDER_PROGRAMS cannot be set to the default location; it will always
 * point to the current user's desktop folder location.  For that reason, it
 * is not possible to install common software on Windows 95 or later once
 * profiles have been enabled.  This is a limitation of Windows.
 */
STRING FOLDER_PROGRAMS;
/**
 * This system variable stores the fully qualified path to the Start Menu
 * folder, which is displayed when you click the Windows Start button.  Note
 * that the menu uses the small version of group, folder, and program icons.
 * <P>
 * The value of FOLDER_STARTMENU changes as follows to ensure that groups and
 * folders are created at the proper location on all Explorer shell operating
 * systems.
 * <UL>
 * <LI>Under Windows NT 4.0, the location pointed to by FOLDER_STARTMENU
 * changes when the default group/folder type is changed from Common to
 * Personal or Personal to Common by calling {@link ProgDefGroupType}.
 * <LI>Under Windows 95 and later, the location pointed to by FOLDER_STARTMENU
 * does not change unless the current user logs out and a different user logs
 * in.  Note that this value will change only if user profiles have been
 * enabled; otherwise the default FOLDER_STARTMENU location is used for all
 * users.
 * </UL>
 * <B>Note:</B>
 * Once user profiles have been enabled on Windows 95 or later,
 * FOLDER_PROGRAMS cannot be set to the default location; it will always
 * point to the current user's desktop folder location.  For that reason, it
 * is not possible to install common software on Windows 95 or later once
 * profiles have been enabled.  This is a limitation of Windows.
 */
STRING FOLDER_STARTMENU;

/**
 * This system variable stores the fully qualified path to the Startup
 * folder, which contains the program folders and items that are launched
 * when Windows starts.
 * <P>
 * The value of FOLDER_STARTUP changes as follows to ensure that groups and
 * folders are created at the proper location on all Explorer shell operating
 * systems.
 * <UL>
 * <LI>Under Windows NT 4.0, the location pointed to by FOLDER_STARTUP changes
 * when the default group/folder type is changed from Common to Personal or
 * Personal to Common by calling {@link ProgDefGroupType}.
 * <LI>Under Windows 95 and later, the location pointed to by FOLDER_STARTUP
 * does not change unless the current user logs out and a different user logs
 * in.  Note that this value will change only if user profiles have been
 * enabled; otherwise the default FOLDER_STARTUP location is used for all
 * users.
 * </UL>
 * <B>Note:</B>
 * Once user profiles have been enabled on Windows 95 or later,
 * FOLDER_PROGRAMS cannot be set to the default location; it will always
 * point to the current user's desktop folder location.  For that reason, it
 * is not possible to install common software on Windows 95 or later once
 * profiles have been enabled.  This is a limitation of Windows.
 */
STRING FOLDER_STARTUP;

/**
 * When you use BatchFileSave to save a batch file or {@link ConfigFileSave} to save
 * a Config.sys file, you can specify that InstallShield create a backup of
 * the file as it existed before you updated it.  InstallShield assigns the
 * name of that backup file to the system variable INFOFILENAME.  If you want
 * to alert the user to the existence of the backup file, use the function
 * {@link MessageBox} to display the value of INFOFILENAME.
 */
STRING INFOFILENAME;

/**
 * During setup initialization, InstallShield decompresses _isres.dll from
 * _user1.cab and copies it to a temporary folder on the target system,
 * giving it a unique name so that it does not interfere with other
 * InstallShield installations.  The fully qualified name of this file, which
 * contains setup resources, is assigned to the system variable ISRES.
 */
STRING ISRES;

/**
 * During setup initialization, InstallShield decompresses _isuser.dll, if
 * present, from _user1.cab and copies it to the temporary folder Supportdir
 * on the target system, giving the file a unique name so that it does not
 * interfere with other InstallShield installations.  The fully qualified
 * name of this file, which contains user-defined setup resources, is
 * assigned to the system variable ISUSER.
 */
STRING ISUSER;

/**
 * When the setup script starts running, InstallShield gets the version of
 * Setup.exe that is running and assigns it to the system variable ISVERSION.
 * The version number also appears in the Setup program's About box.
 */
STRING ISVERSION;

/**
 * This system variable stores the name of the current media library or
 * script-created component set.  During setup initialization, MEDIA is
 * assigned the value of 'DATA', which corresponds to the DATAx.cab file that
 * was created by the media build.  If you change the value of this system
 * variable to refer to a script-created component set, you must change the
 * value back to 'DATA' before calling {@link ComponentMoveData},
 * link CreateShellObjects}, or {@link CreateRegistrySet}.
 */
STRING MEDIA="DATA";

/**
 * The system variable MODE holds one of the following constant values:
 * <UL>
 * <LI>SILENTMODE-Indicates that Setup.exe is running in silent mode.
 * <LI>NORMALMODE-Indicates Setup.exe is running in normal mode.
 * 
 * @example
 * You can use the system variable MODE in if statements to control the flow
 * of your script based on mode, as shown below:
 * <PRE>
 *    if (MODE = SILENTMODE) then
 *       // Perform silent setup actions and events.
 *    else
 *       // Perform normal setup actions and events.
 *    endif;
 * </PRE>
 */
rul_MODE_constants MODE;
private enum rul_MODE_constants {
   // Indicates that Setup.exe is running in silent mode
   SILENTMODE
   // Indicates that Setup.exe is running in normal mode
   NORMALMODE
}

/**
 * This system variable contains the fully qualified name of the folder
 * defined by Windows to store applications.  In English Windows, that folder
 * is named "Program Files" and is located off the root of the drive on which
 * Windows is installed.  (In other language versions of Windows, the folder
 * name is localized appropriately by default.) The program files folders is
 * the recommended default location for application folders.
 * <P>
 * <B>Tip:</B>
 * If your company distributes more than one application, you may prefer to
 * create a company folder inside the program files folder and then create
 * application folders within the company folder.  For example, when
 * InstallShield 5.5 is installed, it is placed by default in the following
 * folder:
 * <PRE>
 *    PROGRAMFILES\InstallShield\InstallShield 5.5 Professional Edition
 * </PRE>
 * During setup initialization, the value of the InstallShield system
 * variable PROGRAMFILES is obtained from the "ProgramFilesDir" value of the
 * following key in the Windows registry:
 * <PRE>
 *    HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion
 * </PRE>
 */
STRING PROGRAMFILES;

/**
 * This numeric system variable contains the ID of the language that the
 * setup is using to display prompts and messages.  For a description of the
 * method by which a setup determines the language to use, refer to the
 * online Help Library.
 */
NUMBER SELECTED_LANGUAGE;

// Contains the fully qualified name of the folder that was selected in 
// SelectFolder; this variable can be referenced by the Displayed 
// Folder/Group Name property.  
STRING SHELL_OBJECT_FOLDER;

/**
 * This system variable contains the fully qualified path to the source
 * folder that contains the compiled setup script.  During setup
 * initialization, InstallShield assigns to SRCDIR the fully qualified path
 * to the folder in which your .ins file is located.
 */
STRING SRCDIR;

/**
 * This system variable contains the name of the drive with the source disk.
 * During setup initialization, InstallShield assigns to SRCDISK the name of
 * the drive that holds the disk containing the setup script file, Setup.ins.
 * For example, if you start Setup.exe from a floppy disk in the A drive,
 * then if that disk contains the file Setup.ins, InstallShield assigns the
 * value "A:" to SRCDISK.  Note that InstallShield includes the colon (:)
 * with the drive letter.
 * <P>
 * <B>Note:</B>
 * If you intend to reference the root folder of the drive specified by this
 * variable, you must append a backslash to it (specified as two
 * backslashes).  For example, if the value of SRCDISK is A:, the following
 * statement refers to the root folder of that drive:
 * <PRE>
 *    SRCDISK + "\\"
 * </PRE>
 */
STRING SRCDISK;

/**
 * During setup initialization, InstallShield locates a folder on the target
 * system into which it can copy temporary files and files that were
 * compressed into _sys1.cab and _user1.cab.  InstallShield assigns to
 * SUPPORTDIR the fully qualified path to that folder.
 */
STRING SUPPORTDIR;

/**
 * During setup initialization, InstallShield assigns to the system variable
 * TARGETDIR the fully qualified path to a target folder on the hard disk.
 * This folder will be the one containing the file Win.ini, usually the
 * Windows folder.  Some InstallScript functions use this variable when
 * performing file operations.  You must set this variable to the folder you
 * want to target before calling these functions.
 */
STRING TARGETDIR;

/**
 * During setup initialization, InstallShield assigns the name of the target
 * disk drive to the system variable TARGETDISK.  This drive will be the one
 * containing the file Win.ini, usually the C: drive.  Note that
 * InstallShield includes the colon (:) with the drive letter.
 * <P>
 * <B>Note:</B>
 * If you intend to reference the root folder of the drive specified by this
 * variable, you must append a backslash to it (specified as two
 * backslashes).  For example, if the value of TARGETDISK is C:, the
 * following statement refers to the root folder of that drive:
 * <PRE>
 *    TARGETDISK + "\\"
 * </PRE>
 */
STRING TARGETDISK;

/**
 * This system variable is provided for compatibility with previous versions
 * of InstallShield.  It contains the fully qualified filename and the
 * command line switch for the copy of Setup.exe placed on the target system
 * to perform uninstallation.
 */
STRING UNINST;

/**
 * InstallShield initializes the system variable WINDIR by assigning to it
 * the name of the folder that contains the main operating environment, for
 * example C:\Windows.
 */
STRING WINDIR;

/**
 * InstallShield initializes the system variable WINDISK by assigning to it
 * the ID of the disk drive that contains the main operating environment.
 * This drive will be the one containing the Windows program, usually the C:
 * drive.  Note that InstallShield includes the colon (:) with the drive
 * letter.
 * <P>
 * <B>Note:</B>
 * If you intend to reference the root folder of the drive specified by this
 * variable, you must append a backslash to it (specified as two
 * backslashes).  For example, if the value of WINDISK is C:, the following
 * statement refers to the root folder of that drive:
 * <PRE>
 *    WINDISK + "\\"
 * </PRE>
 */
STRING WINDISK;

/**
 * During setup initialization, InstallShield initializes the system variable
 * WINSYSDIR by assigning to it the name of the Windows system folder.  This
 * folder is used to store application extensions (DLLs), device drivers, and
 * certain other Windows system files, depending on the version of Windows.
 * <P>
 * The name and location of the Windows folder may vary from one computer to
 * another:
 * <UL>
 * <LI>In English Windows 3.1 and Windows 95 and later, the Windows system
 * folder is named System.  In a default installation on a computer that
 * boots from drive C, its absolute path is C:\Windows\System.
 * <LI>In English Windows NT, the Windows system folder is named System32.  In
 * a default installation on a computer that boots from drive C, its absolute
 * path is C:\Winnt\System32.
 * </UL>
 */
STRING WINSYSDIR;

/**
 * During setup initialization, InstallShield initializes the system variable
 * WINSYSDISK by assigning to it the name of the disk drive that contains
 * Windows system folder, usually the C: drive.  Note that InstallShield
 * includes the colon (:) with the drive letter.
 * <P>
 * <B>Note:</B>
 * If you intend to reference the root folder of the drive specified by this
 * variable, you must append a backslash to it (specified as two
 * backslashes).  For example, if the value of WINSYSDISK is C:, the
 * following statement refers to the root folder of that drive:
 * <PRE>
 *    WINSYSDISK + "\\"
 * </PRE>
 */
STRING WINSYSDISK; 

NUMBER _MAX_LENGTH;
NUMBER _MAX_STRING;
NUMBER ALLCONTROLS;
NUMBER BACK;
NUMBER BADPATH;
NUMBER BADTAGFILE;
NUMBER BINARY;
NUMBER CANCELBUTTON;

NUMBER CC_ERR_FILEFORMATERROR;
NUMBER CC_ERR_FILEREADERROR;
NUMBER CC_ERR_NOCOMPONENTLIST;
NUMBER CC_ERR_OUTOFMEMORY;

NUMBER CHANGEDIR;
NUMBER COLORMODE256;
NUMBER COMBOBOX_ENTER;
NUMBER COMBOBOX_SELECT;
NUMBER COMMANDEX;
NUMBER COMMON;
NUMBER COMP_DONE;

NUMBER COMP_ERR_CREATEDIR;
NUMBER COMP_ERR_DESTCONFLICT;
NUMBER COMP_ERR_FILENOTINLIB;
NUMBER COMP_ERR_FILESIZE;
NUMBER COMP_ERR_FILETOOLARGE;
NUMBER COMP_ERR_HEADER;
NUMBER COMP_ERR_INCOMPATIBLE;
NUMBER COMP_ERR_INTPUTNOTCOMPRESSED;
NUMBER COMP_ERR_INVALIDLIST;
NUMBER COMP_ERR_LAUNCHSERVER;
NUMBER COMP_ERR_MEMORY;
NUMBER COMP_ERR_NODISKSPACE;
NUMBER COMP_ERR_OPENINPUT;
NUMBER COMP_ERR_OPENOUTPUT;
NUMBER COMP_ERR_OPTIONS;
NUMBER COMP_ERR_OUTPUTNOTCOMPRESSED;
NUMBER COMP_ERR_SPLIT;
NUMBER COMP_ERR_TARGET;
NUMBER COMP_ERR_TARGETREADONLY;
NUMBER COMP_ERR_WRITE;

NUMBER COMP_INFO_ATTRIBUTE;
NUMBER COMP_INFO_COMPSIZE;
NUMBER COMP_INFO_DATE;
NUMBER COMP_INFO_INVALIDATEPASSWORD;
NUMBER COMP_INFO_ORIGSIZE;
NUMBER COMP_INFO_SETPASSWORD;
NUMBER COMP_INFO_TIME;
NUMBER COMP_INFO_VERSIONLS;
NUMBER COMP_INFO_VERSIONMS;

NUMBER COMP_NORMAL;

NUMBER COMPONENT_FILEINFO_COMPRESSED;
NUMBER COMPONENT_FILEINFO_COMPRESSENGINE;
NUMBER COMPONENT_FILEINFO_LANGUAGE;
NUMBER COMPONENT_FILEINFO_OS;
NUMBER COMPONENT_FILEINFO_POTENTIALLYLOCKED;
NUMBER COMPONENT_FILEINFO_SELFREGISTERING;
NUMBER COMPONENT_FILEINFO_SHARED;

NUMBER COMPONENT_VIEW_CHANGE;
NUMBER COMPONENT_VIEW_CHILDVIEW;
NUMBER COMPONENT_VIEW_COMPONENT;
NUMBER COMPONENT_VIEW_DESCRIPTION;
NUMBER COMPONENT_VIEW_MEDIA;
NUMBER COMPONENT_VIEW_PARENTVIEW;
NUMBER COMPONENT_VIEW_SIZEAVAIL;
NUMBER COMPONENT_VIEW_SIZETOTAL;
NUMBER COMPONENT_VIEW_TARGETLOCATION;

NUMBER COMPRESSHIGH;
NUMBER COMPRESSLOW;
NUMBER COMPRESSMED;
NUMBER COMPRESSNONE;

NUMBER CONTIGUOUS;

NUMBER COPY_ERR_CREATEDIR;
NUMBER COPY_ERR_NODISKSPACE;
NUMBER COPY_ERR_OPENINPUT;
NUMBER COPY_ERR_OPENOUTPUT;
NUMBER COPY_ERR_TARGETREADONLY;
NUMBER COPY_ERR_MEMORY;

NUMBER DEFAULT;
NUMBER DELETE_EOF;
NUMBER DIALOG;

NUMBER DIALOGTHINFONT;
NUMBER DISABLE;
NUMBER DISKID;

NUMBER DLG_CANCEL;
NUMBER DLG_CDIR;
NUMBER DLG_CDIR_MSG;
NUMBER DLG_CLOSE;
NUMBER DLG_ERR;
NUMBER DLG_ERR_ALREADY_EXISTS;
NUMBER DLG_ERR_ENDDLG;
NUMBER DLG_INIT;
NUMBER DLG_MSG_ALL;
NUMBER DLG_MSG_NOT_HAND;
NUMBER DLG_OK;
NUMBER DRIVEOPEN;
NUMBER EDITBOX_CHANGE;

NUMBER ENABLE;

NUMBER END_OF_FILE;
NUMBER END_OF_LIST;
NUMBER ENHANCED;
NUMBER ENTERDISK_ERRMSG;
NUMBER ENTERDISKBEEP;
NUMBER EQUALS;
NUMBER EXISTS;
NUMBER FADE_IN;
NUMBER FADE_OUT;
NUMBER FAILIFEXISTS;
BOOL FALSE;
NUMBER FDRIVE_NUM;
NUMBER FILE_LINE_LENGTH;
NUMBER FILE_NO_VERSION;
NUMBER FILE_NOT_FOUND;
NUMBER FILE_RD_ONLY;
NUMBER FILE_SRC_EQUAL;
NUMBER FILE_SRC_OLD;
NUMBER FINISHBUTTON;
NUMBER FONT_TITLE;
NUMBER FS_CREATEDIR;
NUMBER FS_DISKONEREQUIRED;
NUMBER FS_DONE;
NUMBER FS_FILENOTINLIB;
NUMBER FS_GENERROR;
NUMBER FS_INCORRECTDISK;
NUMBER FS_LAUNCHPROCESS;
NUMBER FS_OPERROR;
NUMBER FS_OUTOFSPACE;
NUMBER FS_PACKAGING;
NUMBER FS_RESETREQUIRED;
NUMBER FS_TARGETREADONLY;
NUMBER FS_TONEXTDISK;
NUMBER GREATER_THAN;
NUMBER HWND_DESKTOP;
NUMBER HWND_INSTALL;
NUMBER IGNORE_READONLY;
NUMBER INFO;
NUMBER INFO_DESCRIPTION;
NUMBER INFO_IMAGE;
NUMBER INFO_MISC;
NUMBER INFO_SIZE;
NUMBER INFO_SUBCOMPONENT;
NUMBER INFO_VISIBLE;
NUMBER INVALID_LIST;
NUMBER IS_186;
NUMBER IS_286;
NUMBER IS_386;
NUMBER IS_486;
NUMBER IS_8514A;
NUMBER IS_86;
NUMBER IS_ALPHA;
NUMBER IS_CDROM;
NUMBER IS_CGA;
NUMBER IS_DOS;
NUMBER IS_EGA;
NUMBER IS_FIXED;
NUMBER IS_FOLDER;
NUMBER IS_ITEM;
NUMBER IS_MIPS;
NUMBER IS_MONO;
NUMBER IS_OS2;
NUMBER IS_PENTIUM;
NUMBER IS_POWERPC;
NUMBER IS_RAMDRIVE;
NUMBER IS_REMOTE;
NUMBER IS_REMOVABLE;
NUMBER IS_SVGA;
NUMBER IS_UNKNOWN;
NUMBER IS_UVGA;
NUMBER IS_VALID_PATH;
NUMBER IS_VGA;
NUMBER IS_WIN32S;
NUMBER IS_WINDOWS;
NUMBER IS_WINDOWS95;
NUMBER IS_WINDOWSNT;
NUMBER IS_WINOS2;
NUMBER IS_XVGA;
NUMBER LESS_THAN;
NUMBER LINE_NUMBER ;
NUMBER LISTBOX_ENTER;
NUMBER LISTBOX_SELECT;
NUMBER MAINCAPTION;
NUMBER MAX_STRING;
NUMBER MENU;
NUMBER NEXT;
NUMBER NO_WRITE_ACCESS;
NUMBER NONCONTIGUOUS;
NUMBER NORMAL;
NUMBER NOSET;
NUMBER NOTEXISTS;
NUMBER NOTRESET;
NUMBER OK;
NUMBER OTHER_FAILURE;
NUMBER OUT_OF_DISK_SPACE;
NUMBER PAUSE;
NUMBER PROFSTRING;
NUMBER PROGMAN;
NUMBER RAM_DRIVE;
NUMBER REAL;
NUMBER RECORDMODE;
NUMBER REGDB_ERR_CONNECTIONEXISTS;
NUMBER REGDB_ERR_CORRUPTEDREGISTRY;
NUMBER REGDB_ERR_FILECLOSE;
NUMBER REGDB_ERR_FILENOTFOUND;
NUMBER REGDB_ERR_FILEOPEN;
NUMBER REGDB_ERR_FILEREAD;
NUMBER REGDB_ERR_INITIALIZATION;
NUMBER REGDB_ERR_INVALIDFORMAT;
NUMBER REGDB_ERR_INVALIDHANDLE;
NUMBER REGDB_ERR_INVALIDNAME;
NUMBER REGDB_ERR_INVALIDPLATFORM;
NUMBER REGDB_ERR_OUTOFMEMORY;
NUMBER REGDB_ERR_REGISTRY;
NUMBER REGKEY_CLASSES_ROOT;
NUMBER REGKEY_CURRENT_USER;
NUMBER REGKEY_LOCAL_MACHINE;
NUMBER REGKEY_USERS;
NUMBER REPLACE_ITEM;
NUMBER ROTATE;
NUMBER SELECTFOLDER;
NUMBER SET;
NUMBER SETUPTYPE;
NUMBER SPLITCOMPRESS;
NUMBER SPLITCOPY;
NUMBER SRCTARGETDIR;
NUMBER STANDARD;
NUMBER STATUS95;
NUMBER STATUSEX;
NUMBER SW_HIDE;
NUMBER SW_SHOWNORMAL;
NUMBER TEXT;
NUMBER VARIABLE_LEFT;
NUMBER VARIABLE_UNDEFINED;
NUMBER VER_DLL_NOT_FOUND;
NUMBER VERSION;
NUMBER WELCOME;

/**
 * <B>Hungarian Notation Prefixes</B>
 * <P>
 * InstallShield help topics, script templates, and Project Wizard-generated 
 * scripts employ an extended form of Hungarian notation, a naming convention 
 * that uses short, lowercase prefixes to indicate data type.  For example, 
 * iPointSize denotes an integer variable; szFileName indicates a string 
 * variable.  
 * <DL compact>
 * <DT><B>Prefix</B></DT><DD><B>Data type -- InstallScript function syntax</B>
 * <DT><HR>
 * <DT>b      </DT><DD><B>Boolean (BOOL)</B> -- Boolean constant, literal, or variable.
 * <DT>bv     </DT><DD><B>Boolean variable (BOOL)</B> -- Boolean variable only. Constants and literals not allowed.
 * <DT>c      </DT><DD><B>Character (CHAR)</B> -- Character constant, literal, or variable.
 * <DT>const  </DT><DD><B>Constant</B> -- Constant or literal. Variables not allowed.
 * <DT>h      </DT><DD><B>Handle (HWND)</B> -- Handle variable.
 * <DT>I      </DT><DD><B>Integer (INT)</B> -- Integer constant, literal, or variable.
 * <DT>l      </DT><DD><B>Long integer (LONG)</B> -- Long integer constant, literal, or variable.
 * <DT>lv     </DT><DD><B>Long integer variable (LONG)</B> -- Long integer variable only. Constants and literals not allowed.
 * <DT>list   </DT><DD><B>List (LIST)</B> -- List variable.
 * <DT>n      </DT><DD><B>Number (NUMBER)</B> --Number constant, literal, or variable.
 * <DT>nv     </DT><DD><B>Number variable (NUMBER)</B> -- Number variable only. Constants and literals not allowed.
 * <DT>p      </DT><DD><B>Pointer(POINTER)</B> -- Pointer variable.
 * <DT>pstruct</DT><DD><B>Pointer to a defined structure type</B> --Not used.
 * <DT>s      </DT><DD><B>Short integer (SHORT)</B> --Short integer constant, literal, or variable.
 * <DT>sz     </DT><DD><B>String (STRING)</B> --String constant, literal, or variable.
 * <DT>sv     </DT><DD><B>String variable (STRING)</B> --String variable only. Constants and literals not allowed.
 * <DT>struct </DT><DD><B>Defined structure type</B> -- Not used.
 * </DL>
 */
private const rul_notation;

enum rul_data_types {
   /**
    * Boolean constant, literal, or variable.
    * @see rul_notation
    */
   BOOL
   /**
    * Character constant, literal, or variable.
    * @see rul_notation
    */
   CHAR
   /**
    * Handle variable.
    * @see rul_notation
    * @see CmdGetHwndDlg
    * @see CtrlClear
    * @see CtrlGetCurSel
    * @see CtrlGetMultCurSel
    */
   HWND
   /**
    * Integer constant, literal, or variable.
    * @see rul_notation
    */
   INT
   /**
    * Long integer constant, literal, or variable.
    * @see rul_notation
    */
   LONG
   /**
    * List variable.
    * @see rul_notation
    * @see ListAddItem
    * @see ListAddString
    * @see ListReadFromFile
    * @see ListCreate
    * @see ListSetCurrentString
    * @see ListSetCurrentItem
    * @see ListDestroy
    * @see ListDeleteItem
    * @see ListDeleteString
    * @see ListFindItem
    * @see ListGetFirstString
    * @see ListGetFirstItem
    * @see ListGetNextString
    * @see ListGetFirstString
    * @see ListCurrentString
    * @see ListCurrentItem
    * @see ListSetCurrentString
    * @see ListSetCurrentItem
    * @see ListCount
    * @see ListSetIndex
    * @see ComponentListItems
    * @see CtrlGetMultCurSel
    * @see CtrlGetMLEText
    * @see CtrlSetList
    * @see CtrlSetMLEText
    * @see StrGetTokens
    * @see ListWriteToFile
    */
   LIST
   /**
    * Number constant, literal, or variable.
    * @see rul_notation
    */
   NUMBER
   /**
    * Pointer variable.
    * @see rul_notation
    */
   POINTER
   /**
    * Short integer constant, literal, or variable.
    * @see rul_notation
    */
   SHORT
   /**
    * String constant, literal, or variable.
    * @see rul_notation
    */
   LPSTR
   /**
    * String constant, literal, or variable.
    * @see rul_notation
    */
   STRING
}

